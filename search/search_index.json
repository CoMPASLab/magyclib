{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MAGYC: Magnetometer and Gyroscope Calibration","text":"<p>Code  Pypi </p> <p>This site serves as documentation for the <code>magyc</code> library. The goal of this library is to provide a set of tools for the calibration of Attitude and Heading Reference System (AHRS) magnetometers and gyroscopes. The proses of calibration consist of determine the scale and non-orthogonality vectors for the magnetometer, soft-iron (SI), and the biases for the gyroscope and the magnetometer, hard-iron (HI).</p> <p>To solve the calibration problem, this library provides a set of least squares and factor graph method that need the magnetometer and gyroscope measurements, and the timestamp for each one of this samples. As both measurement are from the same device, the timestamp will be the same for both. This library was developed in the context of a research publication in the IEEE Journal of Oceanic Engineering. In this library the user can find the methods developed for this research under the MAGYC: Magnetometer and Gyroscope Calibration novel approach, and as well the benchmark methods implemented.</p> <p>The documentation for the different modules of this library can be found via the navigation bar.</p> <p>If you use this library in your research, please cite the following publication:</p> <pre><code>@misc{rodr\u00edguezmart\u00ednez2024magnetometergyroscopebiasestimation,\n      title={Full Magnetometer and Gyroscope Bias Estimation using Angular Rates: Theory and Experimental Evaluation of a Factor Graph-Based Approach},\n      author={Sebasti\u00e1n Rodr\u00edguez-Mart\u00ednez and Giancarlo Troni},\n      year={2024},\n      eprint={2412.09690},\n      archivePrefix={arXiv},\n      primaryClass={cs.RO},\n      url={https://arxiv.org/abs/2412.09690},\n}\n</code></pre>"},{"location":"example/","title":"Simulated Dataset Calibration","text":"<p>We provide two examples for calibration and evaluation of the MAGYC and benchmark methods as jupyter notebooks. The notebooks are available in the <code>examples</code> directory, and to use them is neccesary to build poetry as:</p> <p><pre><code>poetry build\n</code></pre> Then, you will have all the required dependencies installed.</p>"},{"location":"example/#magyc-example-simulated-data-calibration-self-evaluation","title":"MAGYC Example - Simulated Data Calibration &amp; Self Evaluation","text":"<p>Jupyter Notebook </p> <p>This notebook demonstrates how to use the MAGYC algorithms to calibrate a magnetometer and gyroscope using simulated data and provides a comparison with benchmark methods for calibration. Then, the results are self evaluated.</p> <p>The calibration dataset corresponds to the simulated data used in the paper: \"Full Magnetometer and Gyroscope Bias Estimation Using Angular Rates: Theory and Experimental Evaluation of a Factor Graph-Based Approach\" by S. Rodr\u00edguez-Mart\u00ednez and G. Troni, 2024. The dataset is available on Google Drive.</p>"},{"location":"example/#magyc-example-simulated-data-cross-validation","title":"MAGYC Example - Simulated Data Cross-Validation","text":"<p>Jupyter Notebook </p> <p>This notebook evaluates the MAGYC and benchmark algorithms formagnetometer and gyroscope calibration using simulated data. The calibration dataset corresponds to the simulated data used in the paper: \"Full Magnetometer and Gyroscope Bias Estimation Using Angular Rates: Theory and Experimental Evaluation of a Factor Graph-Based Approach\" by S. Rodr\u00edguez-Mart\u00ednez and G. Troni, 2024. The dataset is available on Google Drive.</p>"},{"location":"simulated_data/","title":"Monte Carlo Simulation","text":"<p>Sim Data </p> <p>A Monte Carlo numerical simulation was conducted to replicate 6,000 measurements from a MEMS AHRS during the sinusoidal motions of a vehicle. This simulation was designed to emulate a magnetometer calibration platform for an articulated vehicle or one with pitching capabilities in the Wide Angular Movement (WAM) dataset, a magnetometer calibration for a roll-and-pitch stable vehicle in the Mid Angular Movement (MAM) dataset, and a survey for a vehicle with the same capabilities as described in WAM for the Low Angular Movement (LAM) dataset.</p> <p>Each experiment lasted 600 s, with simulated data generated at a 10 Hz rate and magnetometer measurements (\\(\\sigma_{mag} = 10\\) mG) and angular rate sensor (\\(\\sigma_{gyro} = 10\\) mrad/s) corrupted by Gaussian noise.</p> <p>The true magnetic field vector is \\(\\mathbf{m_0} = [227,\\, 52, \\,412]^T\\) mG, the soft-iron upper triangular terms are given by \\(\\mathbf{a} = [1.10,\\, 0.10,\\, 0.04,\\, 0.88,\\, 0.02,\\, 1.22]^T\\), the hard-iron bias is \\(\\mathbf{m_b} = [20,\\, 120,\\, 90]^T\\) mG, and the gyroscope bias is \\(\\mathbf{w_b} = [4,\\, -5,\\, 2]^T\\) mrad/s.</p> <p>Note</p> <p>For further details on the simulation, please refer to the section <code>V. Numerical Simulation Evaluation</code> in the paper.</p>"},{"location":"Benchmark%20Methods/ellipsoidfit/","title":"Ellipsoid Fit Implementation","text":"<p>This script aims to implement the ellipsoid fit method proposed in [1] to develop a method for magnetic compass calibration. As the algebraic analysis presented in section (IV) of the paper is not enough for the direct implementation, we will take the algebraic analysis further for the straightforward Python implementation.</p> <p>[1] Liu, Y. X., Li, X. S., Zhang, X. J., &amp; Feng, Y. B. (2014). Novel calibration algorithm for a three-axis strapdown magnetometer. Sensors, 14(5), 8485-8504.</p>"},{"location":"Benchmark%20Methods/ellipsoidfit/#magnetic-calibration-method","title":"Magnetic Calibration method","text":"<p>The measurement of a magnetic compass can be modeled as:</p> \\[ h_m^b = Mh^b + b + n \\] <p>Where \\(b\\) is a constant offset that shifts the output of the sensors, and \\(M\\) accounts for the the sensitivity of the individual axes of the sensor, the non-orthogonality and misalignment of the axes, and the sum of soft-iron errors fixed to the body frame, which serves to scale the sensor's output.</p> <p>When the magnetic compass remains stationary and only changes direction, the magnitude of the true magnetic field \\(||h^b||\\) remains constant, and the locus of the true magnetic field measured \\(h^b\\) is a sphere. Meanwhile, the locus of the disturbed magnetic field measured \\(h_m^b\\) is an ellipsoid, and it can be expressed as follows:</p> \\[ ||h^b||^2 = (h_m^b)^TAh_m^b - 2b^TAh_m^b + b^TAb + \\tilde{n} \\] <p>Where \\(A = G^TG\\), \\(G = M^{-1}\\), and \\(\\tilde{n} = 2(h_m^b-b)^TG^TGn + n^TG^TGn\\). We can see that this is the expression of an ellipsoid in terms of \\(h_m^b\\). In other words, the measurements \\((h_m^b)\\) with errors are constrained to lie on an ellipsoid. Thus, the calibration of the magnetic compass is to seek ellipsoid-fitting methods to solve the coefficients of \\(G\\) and \\(b\\).</p> <p>Since an ellipsoid is a kind of concoid, the ellipsoid equation can be expressed as a general equation of a concoid in the 3-D space as follows:</p> \\[ F(a, h_m^b) = a(h_{mx}^b)^2 + b(h_{mx}^bh_{my}^b) + c (h_{my}^b)^2 + d(h_{mx}^bh_{mz}^b) + e(h_{my}^bh_{mz}^b) + j(h_{mz}^b)^2 + p(h_{mx}^b) + q(h_{my}^b) + r(h_{mz}^b) + s = 0\\] <p>Where \\(a = \\begin{bmatrix} a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; e &amp;&amp; j &amp;&amp; p &amp;&amp; q &amp;&amp; r &amp;&amp; s\\end{bmatrix}^T\\). Moreover, the problem of fitting an ellipsoid into N data points \\(h_m^b\\) can be solved by minimizing the sum of squares of the algebraic distance:</p> \\[ min \\; \\sum_{i}^nF_i(a, h_m^b)^2\\] <p>We define the design matrix (we will use the notation \\(h_j^i\\) to denote the i-th sample of \\(h_{mj}^b\\)), where the i-th row is:</p> \\[ S_i = \\begin{bmatrix} (h_{x}^i)^2 &amp;&amp; h_{x}^ih_{y}^i &amp;&amp; (h_{y}^i)^2 &amp;&amp; h_{x}^ih_{z}^i &amp;&amp; h_{y}^ih_{z}^i &amp;&amp; (h_{z}^i)^2 &amp;&amp; h_{x}^i &amp;&amp; h_{y}^i &amp;&amp; h_{z}^i &amp;&amp; 1 \\end{bmatrix} \\] <p>An additional property of the design matrix is that (S^TS) is symmetric:</p> \\[ (S^TS)^T = (S)^T(S^T)^T = S^TS \\; \\rightarrow \\; (S^TS)^T = S^TS \\] <p>Now, the minimization problem can be presented as:</p> \\[ min \\; ||Sa||^2 \\; \\rightarrow \\; min \\; (Sa)^T(Sa) \\; \\rightarrow \\; min \\; a^TS^TSa\\] <p>In order to avoid the trivial solution \\(a = \\mathbb{O}_{10}\\), and recognizing that any multiple of a solution \\(a\\) represents the same concoid, the parameter vector \\(a\\) is constrained in someway. In order that the surface is fitted to be an ellipsoid in 3D, the parameters \\(a\\) must insure the matrix \\(A\\) to be either positive or negative definite, the equivalent constrained condition is:</p> \\[4ac - b^2 &gt; 0\\] <p>The imposition of this inequality constraint is difficult in general; in this case, we have the freedom to arbitrarily scale the parameters, so we may simply incorporate the scaling into the constraint and impose the equality constraint \\(\\(4ac - b^2 = 1\\)\\), which can be expressed in the matrix form of \\(a^TCa = 1\\), as:</p> \\[ C = \\begin{bmatrix} C_1 &amp;&amp; C_2 \\\\ C_3 &amp;&amp; C_4 \\end{bmatrix},\\; \\text{where:} \\; C_1 = \\begin{bmatrix} 0 &amp;&amp; 0 &amp;&amp; 2 \\\\ 0 &amp;&amp; -1 &amp;&amp; 0 \\\\ 2 &amp;&amp; 0 &amp;&amp; 0 \\end{bmatrix}, \\; C_2 = \\mathbb{O}_{3 \\times 7}, \\; C_3 = \\mathbb{O}_{7 \\times 3}, \\; C_4 = \\mathbb{O}_{7 \\times 7}\\] <p>Notice that as \\(C\\) is a block matrix, \\(C_1 = C_1^T\\), and all the other blocks are zeros:</p> \\[ C^T = \\begin{bmatrix} C_1^T &amp;&amp; C_3^T \\\\ C_2^T &amp;&amp; C_4^T \\end{bmatrix} \\; \\rightarrow \\; C^T = \\begin{bmatrix} C_1 &amp;&amp; C_2 \\\\ C_3 &amp;&amp; C_4 \\end{bmatrix} = C\\] <p>With this additional constraint, the optimization problem is:</p> \\[ min \\; a^TS^TSa \\quad s.t. \\quad a^TCa - 1= 0\\] <p>Using the Lagrange method:</p> \\[ \\mathcal{L}(a) = a^TS^TSa - \\lambda(a^TCa - 1= 0) \\] <p>Differentiating with respect to \\(a\\) we find:</p> \\[ \\frac{\\partial \\mathcal{L}}{\\partial a} = 0 \\; \\rightarrow \\; a^T(S^TS + SS^T) - \\lambda(a^T(C + C^T)) = 0 \\; \\rightarrow \\; 2a^TS^TS - 2\\lambda a^TC = 0 \\; \\rightarrow \\; S^TSa = \\lambda Ca\\] <p>To solve this system, we can rewrite the matrix \\(S^TS\\) as a block matrix:</p> \\[ S^TS = \\begin{bmatrix} X_{11} &amp;&amp; X_{12} \\\\ X_{21} &amp;&amp; X_{22} \\end{bmatrix}, \\text{ where: } X_{11} \\text{ is } 3 \\times 3, \\; X_{12} \\text{ is } 3 \\times 7, \\; X_{21} \\text{ is } 7 \\times 3, \\; X_{22} \\text{ is } 7 \\times 7\\] <p>Furthermore, Using the definition that \\(S^TS\\) is symmetric, then: \\(X_{21} = X_{12}^T\\):</p> \\[ S^TS = \\begin{bmatrix} X_{11} &amp;&amp; X_{12} \\\\ X_{12}^T &amp;&amp; X_{22} \\end{bmatrix}\\] <p>We can also define: \\(a_1 = \\begin{bmatrix} a &amp;&amp; b &amp;&amp; c\\end{bmatrix}^T\\) and \\(a_2 = \\begin{bmatrix} d &amp;&amp; e &amp;&amp; j &amp;&amp; p &amp;&amp; q &amp;&amp; r &amp;&amp; s\\end{bmatrix}^T\\), such that: \\(a = \\begin{bmatrix} a_1 &amp;&amp; a_2\\end{bmatrix}^T\\). Now, we can rewrite the system as:</p> \\[ \\begin{bmatrix} X_{11} &amp;&amp; X_{12} \\\\ X_{12}^T &amp;&amp; X_{22} \\end{bmatrix}\\begin{bmatrix} a_1 \\\\ a_2\\end{bmatrix} = \\lambda \\begin{bmatrix} C_1 &amp;&amp; C_2 \\\\ C_3 &amp;&amp; C_4 \\end{bmatrix}\\begin{bmatrix} a_1 \\\\ a_2\\end{bmatrix} \\] <p>Considering that \\(C_2, C_3, C_4\\) are zero matrices, the first equation that we can get from this is:</p> \\[ X_{11}a_1 + X_{12}a_2 = \\lambda C_1a_1 \\] <p>The second equation is:</p> \\[ X_{12}^Ta_1 + X_{22}a_2 = 0 \\] <p>If the data is not coplanar, the \\(X_{22}\\) will be non-singular:</p> \\[ \\rightarrow a_2 = -X_{22}^{-1}X_{12}^Ta_1 \\] <p>Replacing this term in the first equation, and considering that \\(C_1\\) is non-singular as \\(det(C_1) = 4\\):</p> \\[(X_{11} - \\lambda C_1)a_1 + X_{12}(-X_{22}^{-1}X_{12}^Ta_1) = 0 \\; \\rightarrow \\; C_1^{-1}(X_{11} - X_{12}X_{22}^{-1}X_{12}^T)a_1 = \\lambda a_1 \\] <p>It is proven that exactly one eigenvalue of the last system is positive. Let \\(u_1\\) be the eigenvector associated with the only positive eigenvalue of the general system, then we can get the full solution: \\(u = \\begin{bmatrix} u_1 &amp;&amp; u_2\\end{bmatrix}^T\\). In the case that the matrix \\((X_{11} - X_{12}X_{22}^{-1}X_{12}^T)\\) is singular, the corresponding \\(u_1\\) can be replaced with the eigenvector associated with the largest eigenvalue.</p> <p>With the previously defined equations, we are able to determine the values of: \\(a = \\begin{bmatrix} a &amp;&amp; b &amp;&amp; c &amp;&amp; d &amp;&amp; e &amp;&amp; j &amp;&amp; p &amp;&amp; q &amp;&amp; r &amp;&amp; s\\end{bmatrix}^T\\), and with those values we need to recover the soft-iron and hard-iron, \\(M\\) and \\(b\\), respectively. By definition:</p>"},{"location":"Benchmark%20Methods/ellipsoidfit/#soft-iron","title":"Soft-Iron","text":"\\[ A = \\begin{bmatrix} a &amp;&amp; b/2 &amp;&amp; d/2 \\\\ b/2 &amp;&amp; c &amp;&amp; e/2 \\\\ d/2 &amp;&amp; e/2 &amp;&amp; j \\end{bmatrix} \\] <p>And we also defined that: \\(G^TG = A\\), with \\(G = M^{-1}\\). However, there are uncountable matrices \\(G\\) which can satisfy \\(G^TG = A\\). Thus, we select the x-axis of the sensors as the x-axis of the magnetic compass; thus we can obtain the unique \\(G\\) by singular value decomposition.</p> \\[ G = U_G\\Sigma_G V_G^T \\; \\rightarrow G^TG = (V_G\\Sigma_G^TU_G^T)(U_G\\Sigma_G V_G^T) \\; \\leftrightarrow \\; G^TG = V_G\\Sigma_G^T\\Sigma_G V_G^T \\] <p>As A is a symmetric matrix, then: \\(A^T = A \\; \\rightarrow \\; G^TG = GG^T\\).</p> \\[ G = U_G\\Sigma_G V_G^T \\; \\rightarrow GG^T = (U_G\\Sigma_G V_G^T)(V_G\\Sigma_G^T U_G^T) \\; \\leftrightarrow \\; GG^T = U_G\\Sigma_G \\Sigma_G^T U_G^T \\] <p>If we do the singular value decomposition of A:</p> \\[ V_G\\Sigma_G^T\\Sigma_G V_G^T = U_A \\Sigma_A V_A^T \\qquad \\qquad U_G\\Sigma_G\\Sigma_G^T U_G^T = U_A \\Sigma_A V_A^T \\] <p>Then, as \\(A\\) is a symmetric matrix, then: \\(U = V\\), therefore:</p> \\[ U_G = U_A \\qquad \\qquad V_G = V_A \\qquad \\qquad \\Sigma_G = \\Sigma_A^{1/2} \\] <p>Then:</p> \\[ G = U_G \\Sigma_G V_G^T \\quad \\rightarrow \\quad G = U_A \\Sigma_A^{1/2} V_A^T \\quad \\rightarrow \\quad M = (U_A \\Sigma_A^{1/2} V_A^T)^{-1} \\]"},{"location":"Benchmark%20Methods/ellipsoidfit/#hard-iron","title":"Hard-Iron","text":"<p>From the magnetic field magnitude we found that:</p> \\[ ||h^b||^2 = (h_m^b)^TAh_m^b - 2b^TAh_m^b + b^TAb + \\tilde{n} \\] <p>The first term of that equation is related to the quadratic terms, while the second term is related to the linear terms:</p> \\[ - 2b^TAh_m^b = \\begin{matrix}h_{mx} \\left(- 2 a b_{x} - b b_{y} - b_{z} e\\right) + h_{my} \\left(- b b_{x} - 2 b_{y} c - b_{z} d\\right) + h_{mz} \\left(- b_{x} e - b_{y} d - 2 b_{z} j\\right)\\end{matrix} \\] <p>From the general equation of a concoid in the 3-D space, the linear terms are:</p> \\[ p(h_{mx}^b) + q(h_{my}^b) + r(h_{mz}^b) \\] <p>Therefore, we have the system:</p> \\[ \\begin{bmatrix} 2a &amp;&amp; b &amp;&amp; d \\\\ b &amp;&amp; 2c &amp;&amp; e \\\\ d &amp;&amp; e &amp;&amp; 2j \\end{bmatrix} \\begin{bmatrix} b_x \\\\ b_y \\\\ b_z \\end{bmatrix} = \\begin{bmatrix} p \\\\ q \\\\ r \\end{bmatrix} \\; \\rightarrow \\;  \\begin{bmatrix} b_x \\\\ b_y \\\\ b_z \\end{bmatrix} = \\begin{bmatrix} 2a &amp;&amp; b &amp;&amp; d \\\\ b &amp;&amp; 2c &amp;&amp; e \\\\ d &amp;&amp; e &amp;&amp; 2j \\end{bmatrix} ^{-1} \\begin{bmatrix} p \\\\ q \\\\ r \\end{bmatrix} \\; \\leftrightarrow \\;  \\begin{bmatrix} b_x \\\\ b_y \\\\ b_z \\end{bmatrix} = (2A)^{-1} \\begin{bmatrix} p \\\\ q \\\\ r \\end{bmatrix}\\] <p>MAGYC - Benchmark Methods - Ellipsoid Fit</p> <p>This module contains ellipsoid fit appraches for magnetometer calibration.</p> <p>Functions:</p> Name Description <code>ellipsoid_fit</code> <p>Standard ellipsoid fit method.</p> <code>ellipsoid_fit_fang</code> <p>Ellipsoid fit method by Fang et al.</p>"},{"location":"Benchmark%20Methods/ellipsoidfit/#magyc.benchmark_methods.ellipsoidfit.ellipsoid_fit","title":"<code>ellipsoid_fit(magnetic_field)</code>","text":"<p>The ellipsoid fit method is based on the fact that the error model of a magnetic compass is an ellipsoid, and a constraint least-squares method is adopted to estimate the parameters of an ellipsoid by rotating the magnetic compass in various random orientations.</p> <p>For further details about the implementation, refer to Aleksandr Bazhin Github repository, where he ports to python [matlab's ellipsoid fit].(http://www.mathworks.com/matlabcentral/fileexchange/24693-ellipsoid-fit)</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>soft_iron</code> <code>ndarray</code> <p>Soft iron matrix.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input is not a numpy array or a list.</p> <code>ValueError</code> <p>If the input is not a 3xN or Nx3 numpy array.</p> Source code in <code>magyc/benchmark_methods/ellipsoidfit.py</code> <pre><code>def ellipsoid_fit(magnetic_field: Union[np.ndarray, list]) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    The ellipsoid fit method is based on the fact that the error model of a magnetic\n    compass is an ellipsoid, and a constraint least-squares method is adopted to\n    estimate the parameters of an ellipsoid by rotating the magnetic compass in\n    various random orientations.\n\n    For further details about the implementation, refer to Aleksandr Bazhin [Github\n    repository](https://github.com/aleksandrbazhin/ellipsoid_fit_python), where he\n    ports to python [matlab's ellipsoid fit].(http://www.mathworks.com/matlabcentral/fileexchange/24693-ellipsoid-fit)\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        soft_iron (numpy.ndarray): Soft iron matrix.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements.\n\n    Raises:\n        TypeError: If the input is not a numpy array or a list.\n        ValueError: If the input is not a 3xN or Nx3 numpy array.\n    \"\"\"\n    # Check if the input is a list and convert it to a numpy array\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n\n    # Check if the input is a numpy array\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The input must be a numpy array or a list.\")\n\n    # Check if the input is a 3xN or Nx3 numpy array\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The input must be a 3xN or Nx3 numpy array.\")\n\n    # Force the array to be a Nx3 numpy array\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n\n    # Compute magnetic field calibration\n    x, y, z = magnetic_field[:, 0], magnetic_field[:, 1], magnetic_field[:, 2]\n\n    d_matrix = np.array(\n        [\n            x * x + y * y - 2 * z * z,\n            x * x + z * z - 2 * y * y,\n            2 * x * y,\n            2 * x * z,\n            2 * y * z,\n            2 * x,\n            2 * y,\n            2 * z,\n            1 - 0 * x,\n        ]\n    )\n    d2 = np.array(x * x + y * y + z * z).T\n    u = np.linalg.solve(d_matrix.dot(d_matrix.T), d_matrix.dot(d2))\n    a = np.array([u[0] + 1 * u[1] - 1])\n    b = np.array([u[0] - 2 * u[1] - 1])\n    c = np.array([u[1] - 2 * u[0] - 1])\n    v = np.concatenate([a, b, c, u[2:]], axis=0).flatten()\n    a_matrix = np.array(\n        [[v[0], v[3], v[4], v[6]], [v[3], v[1], v[5], v[7]], [v[4], v[5], v[2], v[8]], [v[6], v[7], v[8], v[9]]]\n    )\n\n    center = np.linalg.solve(-a_matrix[:3, :3], v[6:9])\n\n    translation_matrix = np.eye(4)\n    translation_matrix[3, :3] = center.T\n\n    r_matrix = translation_matrix.dot(a_matrix).dot(translation_matrix.T)\n\n    evals, evecs = np.linalg.eig(r_matrix[:3, :3] / -r_matrix[3, 3])\n    evecs = evecs.T\n\n    radii = np.sqrt(1.0 / np.abs(evals))\n    radii *= np.sign(evals)\n\n    a, b, c = radii\n    r = (a * b * c) ** (1. / 3.)\n    D = np.array([[r/a, 0., 0.], [0., r/b, 0.], [0., 0., r/c]])\n    transformation = evecs.dot(D).dot(evecs.T)\n\n    hard_iron = center.reshape(3, 1)\n    soft_iron = transformation.reshape(3, 3)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = (np.linalg.inv(soft_iron) @ (magnetic_field.reshape(3, -1) - hard_iron.reshape(3, 1))).T\n\n    return hard_iron.flatten(), soft_iron, calibrated_magnetic_field\n</code></pre>"},{"location":"Benchmark%20Methods/ellipsoidfit/#magyc.benchmark_methods.ellipsoidfit.ellipsoid_fit_fang","title":"<code>ellipsoid_fit_fang(magnetic_field)</code>","text":"<p>The ellipsoid fit method is based on the fact that the error model of a magnetic compass is an ellipsoid, and a constraint least-squares method is adopted to estimate the parameters of an ellipsoid by rotating the magnetic compass in various random orientations.</p> <p>For further details about the implementation, refer to section (III) in J. Fang, H. Sun, J. Cao, X. Zhang, and Y. Tao, \u201cA novel calibration method of magnetic compass based on ellipsoid fitting,\u201d IEEE Transactions on Instrumentation and Measurement, vol. 60, no. 6, pp. 2053--2061, 2011.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>soft_iron</code> <code>ndarray</code> <p>Soft iron matrix.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input is not a numpy array or a list.</p> <code>ValueError</code> <p>If the input is not a 3xN or Nx3 numpy array.</p> <code>RuntimeWarning</code> <p>If no positive eigenvalues are found.</p> Source code in <code>magyc/benchmark_methods/ellipsoidfit.py</code> <pre><code>def ellipsoid_fit_fang(magnetic_field: Union[np.ndarray, list]) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    The ellipsoid fit method is based on the fact that the error model of a magnetic\n    compass is an ellipsoid, and a constraint least-squares method is adopted to\n    estimate the parameters of an ellipsoid by rotating the magnetic compass in\n    various random orientations.\n\n    For further details about the implementation, refer to section (III) in J. Fang,\n    H. Sun, J. Cao, X. Zhang, and Y. Tao, \u201cA novel calibration method of magnetic\n    compass based on ellipsoid fitting,\u201d IEEE Transactions on Instrumentation\n    and Measurement, vol. 60, no. 6, pp. 2053--2061, 2011.\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        soft_iron (numpy.ndarray): Soft iron matrix.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements.\n\n    Raises:\n        TypeError: If the input is not a numpy array or a list.\n        ValueError: If the input is not a 3xN or Nx3 numpy array.\n        RuntimeWarning: If no positive eigenvalues are found.\n    \"\"\"\n    # Check if the input is a list and convert it to a numpy array\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n\n    # Check if the input is a numpy array\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The input must be a numpy array or a list.\")\n\n    # Check if the input is a 3xN or Nx3 numpy array\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The input must be a 3xN or Nx3 numpy array.\")\n\n    # Force the array to be a Nx3 numpy array\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n\n    # Compute magnetic field calibration\n    # Design matrix (S)\n    s = np.concatenate(\n        [\n            np.square(magnetic_field[:, [0]]),\n            magnetic_field[:, [0]] * magnetic_field[:, [1]],\n            np.square(magnetic_field[:, [1]]),\n            magnetic_field[:, [0]] * magnetic_field[:, [2]],\n            magnetic_field[:, [1]] * magnetic_field[:, [2]],\n            np.square(magnetic_field[:, [2]]),\n            magnetic_field[:, :],\n            np.ones((magnetic_field.shape[0], 1)),\n        ],\n        axis=1,\n    )\n\n    # Block Matrices: S_11, S_12, S_22\n    sTs = s.T @ s\n    s_11, s_12, s_22 = sTs[:3, :3], sTs[:3, 3:], sTs[3:, 3:]\n\n    # Constrain matrix C_11\n    c_11 = np.array([[0, 0, 2], [0, -1, 0], [2, 0, 0]])\n\n    # Ellipsoid Parameters Estimation\n    eigenvals, eigenvecs = np.linalg.eig(np.linalg.inv(c_11) @ (s_11 - s_12 @ np.linalg.inv(s_22) @ s_12.T))\n\n    if np.max(eigenvals) &lt; 0:\n        warnings.warn(\"No positive eigenvalues: max eigenvalue = {:.6f}\".format(np.max(eigenvals)), RuntimeWarning)\n\n    a_1 = -eigenvecs[:, [np.argmax(eigenvals)]]\n    a_2 = -np.linalg.inv(s_22) @ s_12.T @ a_1\n    a = np.concatenate([a_1, a_2], axis=0).flatten()\n\n    # Determine A and b\n    a_matrix = np.array([[a[0], a[1]/2, a[3]/2], [a[1]/2, a[2], a[4]/2], [a[3]/2, a[4]/2, a[5]]])\n    hard_iron = np.linalg.inv(-2*a_matrix) @ np.vstack(a[6:9])\n\n    # Determine G and M\n    u, s, vh = np.linalg.svd(a_matrix)\n    g = u @ np.sqrt(np.diag(s)) @ vh\n    soft_iron = np.linalg.inv(g)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = (np.linalg.inv(soft_iron) @ (magnetic_field.reshape(3, -1) - hard_iron.reshape(3, 1))).T\n\n    return hard_iron.flatten(), soft_iron, calibrated_magnetic_field\n</code></pre>"},{"location":"Benchmark%20Methods/magcalgyro/","title":"Magnetometer Calibration Gyro Aided","text":"<p>The linear least squares for sensor bias calibration is seeks to minimize the sum of squared residuals</p> \\[\\sum_{i=1}^{n} \\frac{1}{\\sigma_i^2} ||\\dot{x}_i + \\omega_i \\times (x_i - b)||^2\\] <p>Where \\(x(t)\\) is the measured magnetic field, \\(\\dot{x(t)}\\) is the measured magnetic field differentiated with respect to time, \\(\\omega(t)\\) is the measured angular-rate in instrument coordinates, \\(b\\) is the hard-iron, and \\(\\times\\) is the standard cross product operator.</p> <p>This optimization problem can be solved in an analytical way. For further information refer to section IV.A in Troni, G. and Whitcomb, L. L. (2019). Field sensor bias calibration with angular-rate sensors: Theory and experimental evaluation with application to magnetometer calibration. IEEE/ASME Transactions on Mechatronics, 24(4):1698--1710.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>angular_rate</code> <code>ndarray or list</code> <p>Angular rate measurements in a 3xN or Nx3 numpy array or list.</p> required <code>time</code> <code>ndarray or list</code> <p>Time measurements in a 1D numpy array or list.</p> required <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field, angular rate, or time are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field, angular rate, or time are not 3xN or Nx3 numpy arrays.</p> <code>ValueError</code> <p>If the magnetic field, angular rate, and time do not have the same number of samples.</p> Source code in <code>magyc/benchmark_methods/sar.py</code> <pre><code>def sar_ls(magnetic_field: Union[np.ndarray, list], angular_rate: Union[np.ndarray, list],\n           time: Union[np.ndarray, list]) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    The linear least squares for sensor bias calibration is seeks to minimize the\n    sum of squared residuals\n\n    $$\\\\sum_{i=1}^{n} \\\\frac{1}{\\\\sigma_i^2} ||\\\\dot{x}_i + \\\\omega_i \\\\times (x_i - b)||^2$$\n\n    Where $x(t)$ is the measured magnetic field, $\\\\dot{x(t)}$ is the measured\n    magnetic field differentiated with respect to time, $\\\\omega(t)$ is the\n    measured angular-rate in instrument coordinates, $b$ is the hard-iron, and\n    $\\\\times$ is the standard cross product operator.\n\n    This optimization problem can be solved in an analytical way. For further\n    information refer to section IV.A in Troni, G. and Whitcomb, L. L. (2019).\n    Field sensor bias calibration with angular-rate sensors: Theory and experimental\n    evaluation with application to magnetometer calibration. IEEE/ASME Transactions\n    on Mechatronics, 24(4):1698--1710.\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        angular_rate (numpy.ndarray or list): Angular rate measurements in a 3xN or\n            Nx3 numpy array or list.\n        time (numpy.ndarray or list): Time measurements in a 1D numpy array or list.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements\n\n    Raises:\n        TypeError: If the magnetic field, angular rate, or time are not numpy arrays or lists.\n        ValueError: If the magnetic field, angular rate, or time are not 3xN or Nx3 numpy arrays.\n        ValueError: If the magnetic field, angular rate, and time do not have the same number of samples.\n    \"\"\"\n    # Check if the magnetic_field, angular_rate, and time are lists and convert them to numpy arrays\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n    if isinstance(angular_rate, list):\n        angular_rate = np.array(angular_rate)\n    if isinstance(time, list):\n        time = np.array(time)\n\n    # Check if the magnetic_field, angular_rate, and time are numpy arrays\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field must be a numpy array or a list.\")\n    if not isinstance(angular_rate, np.ndarray):\n        raise TypeError(\"The angular rate must be a numpy array or a list.\")\n    if not isinstance(time, np.ndarray):\n        raise TypeError(\"The time must be a numpy array or a list.\")\n\n    # Check if the magnetic_field and angular_rate are 3xN or Nx3 numpy arrays\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field must be a 3xN or Nx3 numpy array.\")\n    if angular_rate.ndim != 2 or (angular_rate.shape[0] != 3 and angular_rate.shape[1] != 3):\n        raise ValueError(\"The angular rate must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the time is a 1D numpy array\n    time = time.flatten()\n    if time.ndim != 1:\n        raise ValueError(\"The time must be a (n, ), (n, 1) or (1, n) numpy array.\")\n\n    # Force the magnetic_field and angular_rate to be Nx3 numpy arrays\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n    if angular_rate.shape[0] == 3:\n        angular_rate = angular_rate.T\n\n    # Check if the magnetic_field, angular_rate, and time have the same number of samples\n    if magnetic_field.shape[0] != angular_rate.shape[0] or magnetic_field.shape[0] != time.shape[0]:\n        raise ValueError(\"The magnetic field, angular rate, and time must have the same number of samples.\")\n\n    # Compute the magnetic calibration\n    # Get the data variance\n    magnetic_field_variance = _get_sigma_noise(magnetic_field)\n    sigma_i = np.linalg.norm(magnetic_field_variance).reshape(-1, 1, 1)\n\n    # Compute the skew-symmetric matrix of the angular rate.\n    skew_symmetric_angular_rate = np.apply_along_axis(nm.vec_to_so3, 1, angular_rate)\n\n    # Compute the magnetic field derivative\n    magnetic_field_derivative = np.diff(magnetic_field, axis=0) / np.diff(time).reshape(-1, 1)\n    magnetic_field_derivative = np.concatenate([np.zeros((1, 3)), magnetic_field_derivative], axis=0)\n\n    # Estimate b\n    b1_inv = np.linalg.inv(np.einsum(\"ijk-&gt;jk\", (skew_symmetric_angular_rate ** 2) * (1 / sigma_i)))\n\n    yi = np.einsum(\n        \"ijk-&gt;ikj\",\n        np.cross(angular_rate.reshape(-1, 1, 3), magnetic_field.reshape(-1, 1, 3))\n        + magnetic_field_derivative.reshape(-1, 1, 3),\n    )\n    b2 = np.einsum(\"ijk-&gt;jk\", (skew_symmetric_angular_rate @ yi) * (1 / sigma_i))\n\n    hard_iron = b1_inv @ b2\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = magnetic_field - hard_iron.flatten()\n\n    return hard_iron.flatten(), calibrated_magnetic_field\n</code></pre> <p>The Kalman filter for sensor bias calibration uses the system model with  a discretization of the continuous-time system the sensor bias estimation can be solved with a standard discrete-time Kalman filter implementation that does not require differentiation.</p> \\[\\dot{x}_i = -\\omega_i \\times (x_i - b)\\] <p>Where \\(x(t)\\) is the measured magnetic field, \\(\\dot{x(t)}\\) is the measured magnetic field differentiated with respect to time, \\(\\omega(t)\\) is the measured angular-rate in instrument coordinates, and \\(b\\) is the hard-iron.</p> <p>For further information refer to section IV.B in Troni, G. and Whitcomb, L. L. (2019). Field sensor bias calibration with angular-rate sensors: Theory and experimental evaluation with application to magnetometer calibration. IEEE/ASME Transactions on Mechatronics, 24(4):1698--1710.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>angular_rate</code> <code>ndarray or list</code> <p>Angular rate measurements in a 3xN or Nx3 numpy array or list.</p> required <code>time</code> <code>ndarray or list</code> <p>Time measurements in a 1D numpy array or list.</p> required <code>gains</code> <code>tuple</code> <p>Kalman filter gains.</p> <code>(1.0, 1.0)</code> <code>f_normalize</code> <code>bool</code> <p>Whether the k2 gain should be scaled by and adaptive constant computed as the reciprocal of the norm of the gyroscope measurement for that step, by default False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements</p> <code>calibrated_filteres_magnetic_field</code> <code>ndarray</code> <p>Calibrated and filtered magnetic field measurements</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field, angular rate, or time are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field, angular rate, or time are not 3xN or Nx3 numpy arrays.</p> <code>ValueError</code> <p>If the magnetic field, angular rate, and time do not have the same number of samples.</p> <code>TypeError</code> <p>If the gains are not a tuple of floats.</p> <code>TypeError</code> <p>If the f_normalize is not a boolean.</p> Source code in <code>magyc/benchmark_methods/sar.py</code> <pre><code>def sar_kf(magnetic_field: Union[np.ndarray, list], angular_rate: Union[np.ndarray, list],\n           time: Union[np.ndarray, list], gains: Tuple[float, float] = (1.0, 1.0),\n           f_normalize: bool = False) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    The Kalman filter for sensor bias calibration uses the system model with  a\n    discretization of the continuous-time system the sensor bias estimation can\n    be solved with a standard discrete-time Kalman filter implementation that\n    does not require differentiation.\n\n    $$\\\\dot{x}_i = -\\\\omega_i \\\\times (x_i - b)$$\n\n    Where $x(t)$ is the measured magnetic field, $\\\\dot{x(t)}$ is the measured\n    magnetic field differentiated with respect to time, $\\\\omega(t)$ is the\n    measured angular-rate in instrument coordinates, and $b$ is the hard-iron.\n\n    For further information refer to section IV.B in Troni, G. and Whitcomb, L. L.\n    (2019). Field sensor bias calibration with angular-rate sensors: Theory and\n    experimental evaluation with application to magnetometer calibration. IEEE/ASME\n    Transactions on Mechatronics, 24(4):1698--1710.\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        angular_rate (numpy.ndarray or list): Angular rate measurements in a 3xN or\n            Nx3 numpy array or list.\n        time (numpy.ndarray or list): Time measurements in a 1D numpy array or list.\n        gains (tuple): Kalman filter gains.\n        f_normalize (bool): Whether the k2 gain should be scaled by and adaptive\n            constant computed as the reciprocal of the norm of the gyroscope measurement\n            for that step, by default False.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements\n        calibrated_filteres_magnetic_field (numpy.ndarray): Calibrated and filtered magnetic field measurements\n\n    Raises:\n        TypeError: If the magnetic field, angular rate, or time are not numpy arrays or lists.\n        ValueError: If the magnetic field, angular rate, or time are not 3xN or Nx3 numpy arrays.\n        ValueError: If the magnetic field, angular rate, and time do not have the same number of samples.\n        TypeError: If the gains are not a tuple of floats.\n        TypeError: If the f_normalize is not a boolean.\n    \"\"\"\n    # Check if the magnetic_field, angular_rate, and time are lists and convert them to numpy arrays\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n    if isinstance(angular_rate, list):\n        angular_rate = np.array(angular_rate)\n    if isinstance(time, list):\n        time = np.array(time)\n\n    # Check if the magnetic_field, angular_rate, and time are numpy arrays\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field must be a numpy array or a list.\")\n    if not isinstance(angular_rate, np.ndarray):\n        raise TypeError(\"The angular rate must be a numpy array or a list.\")\n    if not isinstance(time, np.ndarray):\n        raise TypeError(\"The time must be a numpy array or a list.\")\n\n    # Check if the magnetic_field and angular_rate are 3xN or Nx3 numpy arrays\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field must be a 3xN or Nx3 numpy array.\")\n    if angular_rate.ndim != 2 or (angular_rate.shape[0] != 3 and angular_rate.shape[1] != 3):\n        raise ValueError(\"The angular rate must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the time is a 1D numpy array\n    time = time.flatten()\n    if time.ndim != 1:\n        raise ValueError(\"The time must be a (n, ), (n, 1) or (1, n) numpy array.\")\n\n    # Force the magnetic_field and angular_rate to be Nx3 numpy arrays\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n    if angular_rate.shape[0] == 3:\n        angular_rate = angular_rate.T\n\n    # Check if the magnetic_field, angular_rate, and time have the same number of samples\n    if magnetic_field.shape[0] != angular_rate.shape[0] or magnetic_field.shape[0] != time.shape[0]:\n        raise ValueError(\"The magnetic field, angular rate, and time must have the same number of samples.\")\n\n    # Check that the gains are a tuple of floats\n    if not isinstance(gains, tuple):\n        raise TypeError(\"The gains must be a tuple of floats.\")\n    if not all(isinstance(gain, float) for gain in gains):\n        raise TypeError(\"The gains must be a tuple of floats.\")\n\n    # Check that the f_normalize is a boolean\n    if not isinstance(f_normalize, bool):\n        raise TypeError(\"The f_normalize must be a boolean.\")\n\n    # Compute the magnetic calibration\n    # Initial parameters\n    b0 = np.zeros((3, ))\n    k1a = gains[0]\n    k1b = gains[1] if len(gains) &gt;= 2 else gains[0]\n    k2 = gains[2] if len(gains) &gt;= 3 else gains[1]\n    mf = magnetic_field.reshape(3, -1)\n    w = angular_rate.reshape(3, -1)\n    dt = np.diff(time)\n    dt_vec = np.concatenate([np.array([dt[0]]), dt])\n\n    # Kalman Model\n    Bc = np.zeros([6, 1])\n    # Measurement model\n    H1 = np.hstack([np.eye(3), np.zeros([3, 3])])\n    # Process noise covariance\n    Qc = np.diag([k1a, k1a, k1a, k1b, k1b, k1b])\n    # Variance in the measurements\n    R = np.diag([k2, k2, k2])\n\n    # KF\n    F1 = _kf_transition_matrix([0, 0, 0])\n    n = F1.shape[0]\n    m = F1.shape[1]\n    MM = np.zeros([n, mf.shape[1]])\n    PP = np.zeros([n, m, mf.shape[1]])\n    AA = np.zeros([n, m, mf.shape[1]])\n    QQ = np.zeros([n, m, mf.shape[1]])\n    KK = np.zeros([n, H1.shape[0], mf.shape[1]])\n\n    # Initial guesses for the state mean and covariance.\n    x = np.hstack([mf[:, 0], b0])\n    p01 = 0.001  # P0 gyro\n    p02 = 0.001  # P0 bias\n    P0 = np.diag([p01, p01, p01, p02, p02, p02])\n    P = P0\n\n    # Filtering steps.\n    for ix in range(mf.shape[1]):\n        # Discretization of the continous-time system (dtk)\n        dtk = dt_vec[ix]\n        u = w[:, ix]\n\n        [Ak, Bk, Qk] = _kf_lti_discretize(_kf_transition_matrix(u), Bc, Qc, dtk)\n\n        AA[:, :, ix] = Ak\n        QQ[:, :, ix] = Qk\n\n        # Prediction\n        [x, P] = _kf_predict(x, P, Ak, Qk)\n        [x, P, K, dy, S] = _kf_update(x, P, mf[:, ix], H1, R)\n\n        MM[:, ix] = x\n        PP[:, :, ix] = P\n        KK[:, :, ix] = K\n\n    # Final Bias averaging last 20%\n    hard_iron = np.mean(MM[3:, -int(np.round(mf.shape[1]*0.2)):], axis=1, keepdims=True)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = magnetic_field - hard_iron.flatten()\n    calibrated_filteres_magnetic_field = MM[:3, :].T\n\n    return hard_iron.flatten(), calibrated_magnetic_field, calibrated_filteres_magnetic_field\n</code></pre> <p>The adaptive identification for sensor bias calibration proposes that the unknown sensor bias, \\(b\\), can be estimated on-line with a novel adaptive identification algorithm. The possible advantages of this adaptive approach are that (i) it does not require numerical differentiation of the sensor measurement \\(x(t)\\), (ii) it is less computationally expensive than the SAR-KF, and (iii) it could be combined with other nonlinear observer methods.</p> <p>For further information refer to section IV.C in Troni, G. and Whitcomb, L. L. (2019). Field sensor bias calibration with angular-rate sensors: Theory and experimental evaluation with application to magnetometer calibration. IEEE/ASME Transactions on Mechatronics, 24(4):1698--1710.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>angular_rate</code> <code>ndarray or list</code> <p>Angular rate measurements in a 3xN or Nx3 numpy array or list.</p> required <code>time</code> <code>ndarray or list</code> <p>Time measurements in a 1D numpy array or list.</p> required <code>gains</code> <code>tuple</code> <p>Gains defined in the set of equations (5) of the proposed method as a tuple of floats, by default (1.0, 1.0)</p> <code>(1.0, 1.0)</code> <code>f_normalize</code> <code>bool</code> <p>Whether the k2 gain should be scaled by and adaptive constant computed as the reciprocal of the norm of the gyroscope measurement for that step, by default False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements</p> <code>calibrated_filtered_magnetic_field</code> <code>ndarray</code> <p>Calibrated and filtered magnetic field measurements</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field, angular rate, or time are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field, angular rate, or time are not 3xN or Nx3 numpy arrays.</p> <code>ValueError</code> <p>If the magnetic field, angular rate, and time do not have the same number of samples.</p> <code>TypeError</code> <p>If the gains are not a tuple of floats.</p> <code>TypeError</code> <p>If the f_normalize is not a boolean.</p> Source code in <code>magyc/benchmark_methods/sar.py</code> <pre><code>def sar_aid(magnetic_field: Union[np.ndarray, list], angular_rate: Union[np.ndarray, list],\n            time: Union[np.ndarray, list], gains: Tuple[float, float] = (1.0, 1.0),\n            f_normalize: bool = False) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    The adaptive identification for sensor bias calibration proposes that the\n    unknown sensor bias, $b$, can be estimated on-line with a novel adaptive\n    identification algorithm. The possible advantages of this adaptive approach\n    are that (i) it does not require numerical differentiation of the sensor\n    measurement $x(t)$, (ii) it is less computationally expensive than the SAR-KF,\n    and (iii) it could be combined with other nonlinear observer methods.\n\n    For further information refer to section IV.C in Troni, G. and Whitcomb, L. L.\n    (2019). Field sensor bias calibration with angular-rate sensors: Theory and\n    experimental evaluation with application to magnetometer calibration. IEEE/ASME\n    Transactions on Mechatronics, 24(4):1698--1710.\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        angular_rate (numpy.ndarray or list): Angular rate measurements in a 3xN or\n            Nx3 numpy array or list.\n        time (numpy.ndarray or list): Time measurements in a 1D numpy array or list.\n        gains (tuple): Gains defined in the set of equations (5) of the proposed method as\n            a tuple of floats, by default (1.0, 1.0)\n        f_normalize (bool): Whether the k2 gain should be scaled by and adaptive\n            constant computed as the reciprocal of the norm of the gyroscope measurement\n            for that step, by default False.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements\n        calibrated_filtered_magnetic_field (numpy.ndarray): Calibrated and filtered magnetic field measurements\n\n    Raises:\n        TypeError: If the magnetic field, angular rate, or time are not numpy arrays or lists.\n        ValueError: If the magnetic field, angular rate, or time are not 3xN or Nx3 numpy arrays.\n        ValueError: If the magnetic field, angular rate, and time do not have the same number of samples.\n        TypeError: If the gains are not a tuple of floats.\n        TypeError: If the f_normalize is not a boolean.\n    \"\"\"\n    # Check if the magnetic_field, angular_rate, and time are lists and convert them to numpy arrays\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n    if isinstance(angular_rate, list):\n        angular_rate = np.array(angular_rate)\n    if isinstance(time, list):\n        time = np.array(time)\n\n    # Check if the magnetic_field, angular_rate, and time are numpy arrays\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field must be a numpy array or a list.\")\n    if not isinstance(angular_rate, np.ndarray):\n        raise TypeError(\"The angular rate must be a numpy array or a list.\")\n    if not isinstance(time, np.ndarray):\n        raise TypeError(\"The time must be a numpy array or a list.\")\n\n    # Check if the magnetic_field and angular_rate are 3xN or Nx3 numpy arrays\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field must be a 3xN or Nx3 numpy array.\")\n    if angular_rate.ndim != 2 or (angular_rate.shape[0] != 3 and angular_rate.shape[1] != 3):\n        raise ValueError(\"The angular rate must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the time is a 1D numpy array\n    time = time.flatten()\n    if time.ndim != 1:\n        raise ValueError(\"The time must be a (n, ), (n, 1) or (1, n) numpy array.\")\n\n    # Force the magnetic_field and angular_rate to be Nx3 numpy arrays\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n    if angular_rate.shape[0] == 3:\n        angular_rate = angular_rate.T\n\n    # Check if the magnetic_field, angular_rate, and time have the same number of samples\n    if magnetic_field.shape[0] != angular_rate.shape[0] or magnetic_field.shape[0] != time.shape[0]:\n        raise ValueError(\"The magnetic field, angular rate, and time must have the same number of samples.\")\n\n    # Check that the gains are a tuple of floats\n    if not isinstance(gains, tuple):\n        raise TypeError(\"The gains must be a tuple of floats.\")\n    if not all(isinstance(gain, float) for gain in gains):\n        raise TypeError(\"The gains must be a tuple of floats.\")\n\n    # Check that the f_normalize is a boolean\n    if not isinstance(f_normalize, bool):\n        raise TypeError(\"The f_normalize must be a boolean.\")\n\n    # Compute the magnetic calibration\n    # Initial parameters\n    b0 = np.zeros((3, ))\n    k1 = gains[0]\n    k2 = gains[1]\n    mf = magnetic_field.reshape(3, -1)\n    w = angular_rate.reshape(3, -1)\n    dt = np.diff(time)\n    dt_vec = np.concatenate([np.array([dt[0]]), dt])\n\n    # Compute the skew-symmetric matrix of the angular rate.\n    skew_symmetric_angular_rate = np.apply_along_axis(nm.vec_to_so3, 1, angular_rate)\n\n    # Adaptive ID system\n    mh = np.zeros((3, mf.shape[1] + 1))\n    mhd = np.zeros((3, mf.shape[1]))\n    bh = np.zeros((3, mf.shape[1] + 1))\n    bhd = np.zeros((3, mf.shape[1]))\n    mh[:, 0] = magnetic_field[0, :]\n    bh[:, 0] = b0\n\n    for ix in range(mf.shape[1]):\n        mhd[:, ix] = (\n            - skew_symmetric_angular_rate[ix, :, :] @ mh[:, ix]\n            + skew_symmetric_angular_rate[ix, :, :] @ bh[:, ix]\n            - k1 * (mh[:, ix] - mf[:, ix])\n        )\n\n        if (np.linalg.norm(w[:, ix]) &gt; 0.01) and f_normalize:\n            k_adap = 1 / np.linalg.norm(w[:, ix])\n            bhd[:, ix] = -k_adap * k2 * skew_symmetric_angular_rate[ix, :, :] @ (mh[:, ix] - mf[:, ix])\n        else:\n            bhd[:, ix] = -k2 * skew_symmetric_angular_rate[ix, :, :].T @ (mh[:, ix] - mf[:, ix])\n\n        mh[:, ix + 1] = mh[:, ix] + dt_vec[ix] * mhd[:, ix]\n        bh[:, ix + 1] = bh[:, ix] + dt_vec[ix] * bhd[:, ix]\n\n    # Final Bias averaging last 20%\n    hard_iron = np.mean(bh[:, -int(np.round(mf.shape[1] * 0.2)):], axis=1, keepdims=True)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = magnetic_field - hard_iron.flatten()\n    calibrated_filtered_magnetic_field = mh[:, :-1].T\n\n    return hard_iron.flatten(), calibrated_magnetic_field, calibrated_filtered_magnetic_field\n</code></pre>"},{"location":"Benchmark%20Methods/magfactor3/","title":"GTSAM magFactor3","text":"<p>MAGYC - Benchmark Methods - magfactor3</p> <p>This module contains the magfactor3 method. This method is a factor graph implementation of the full-magnetometer calibration least-squares problems.</p> <p>Functions:</p> Name Description <code>magfactor3</code> <p>Factor graph based approach to full-magnetometer calibration.</p>"},{"location":"Benchmark%20Methods/magfactor3/#magyc.benchmark_methods.magfactor.magfactor3","title":"<code>magfactor3(magnetic_field, rph, magnetic_declination, reference_magnetic_field, optimizer='dogleg', relative_error_tol=1e-12, absolute_error_tol=1e-12, max_iter=1000)</code>","text":"<p>The full-magnetometer calibration least-squares problems can also be modeled as a factor graph. This can be implemented using the GTSAM python wrapper with the magFactor3 factor. This approach allows the user to get the soft-iron (SI) as the identity scaled by a constant and the hard-iron (HI) from the magnetometer bias.</p> <p>This method assumes that the rotation from the body frame with respect to the world frame and the local magnetic field are known.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>Union[ndarray, list]</code> <p>Magnetic field raw data</p> required <code>rph</code> <code>Union[ndarray, list]</code> <p>Roll, pitch and heading data</p> required <code>magnetic_declination</code> <code>float</code> <p>Magnetic declination in degrees</p> required <code>reference_magnetic_field</code> <code>Union[ndarray, list]</code> <p>Reference magnetic field</p> required <code>optimizer</code> <code>str</code> <p>Optimization algorithm to use. Options are \"dogleg\" or \"lm\" for the Dogleg and Levenberg-Marquardt optimizers respectively.</p> <code>'dogleg'</code> <code>relative_error_tol</code> <code>float</code> <p>Relative error tolerance for the optimizer. Default is 1.00e-12</p> <code>1e-12</code> <code>absolute_error_tol</code> <code>float</code> <p>Absolute error tolerance for the optimizer. Default is 1.00e-12</p> <code>1e-12</code> <code>max_iter</code> <code>int</code> <p>Maximum number of iterations for the optimizer. Default is 1000</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard-iron offset in G</p> <code>soft_iron</code> <code>ndarray</code> <p>Soft-iron scaling matrix</p> <code>corrected_magnetic_field</code> <code>ndarray</code> <p>Corrected magnetic field data</p> <code>optimization_errors</code> <code>list</code> <p>List of optimization errors in each iteration</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field input is not a numpy array or a list</p> <code>TypeError</code> <p>If the reference magnetic field input is not a numpy array or a list</p> <code>TypeError</code> <p>If the rph input is not a numpy array or a list</p> <code>ValueError</code> <p>If the magnetic field input is not a 3xN or Nx3 numpy array</p> <code>ValueError</code> <p>If the reference magnetic field input is not a 3, numpy array</p> <code>ValueError</code> <p>If the rph input is not a 3xN or Nx3 numpy array</p> <code>TypeError</code> <p>If the magnetic declination is not a float</p> <code>ValueError</code> <p>If the optimizer is not a string or not \"dogleg\" or \"lm\"</p> <code>TypeError</code> <p>If the relative error tolerance is not a float</p> <code>TypeError</code> <p>If the absolute error tolerance is not a float</p> <code>ValueError</code> <p>If the maximum number of iterations is not a positive integer</p> Source code in <code>magyc/benchmark_methods/magfactor.py</code> <pre><code>def magfactor3(magnetic_field: Union[np.ndarray, list], rph: Union[np.ndarray, list], magnetic_declination: float,\n               reference_magnetic_field: Union[np.ndarray, list], optimizer: str = \"dogleg\",\n               relative_error_tol: float = 1.00e-12, absolute_error_tol: float = 1.00e-12,\n               max_iter: int = 1000) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, list]:\n    \"\"\"\n    The full-magnetometer calibration least-squares problems can also be modeled\n    as a factor graph. This can be implemented using the [GTSAM](https://github.com/borglab/gtsam)\n    python wrapper with the magFactor3 factor. This approach allows the user to get the soft-iron\n    (SI) as the identity scaled by a constant and the hard-iron (HI) from the\n    magnetometer bias.\n\n    This method assumes that the rotation from the body frame with respect to\n    the world frame and the local magnetic field are known.\n\n    Args:\n        magnetic_field (Union[np.ndarray, list]): Magnetic field raw data\n        rph (Union[np.ndarray, list]): Roll, pitch and heading data\n        magnetic_declination (float): Magnetic declination in degrees\n        reference_magnetic_field (Union[np.ndarray, list]): Reference magnetic field\n        optimizer (str): Optimization algorithm to use. Options are \"dogleg\" or \"lm\"\n            for the Dogleg and Levenberg-Marquardt optimizers respectively.\n        relative_error_tol (float): Relative error tolerance for the optimizer. Default is 1.00e-12\n        absolute_error_tol (float): Absolute error tolerance for the optimizer. Default is 1.00e-12\n        max_iter (int): Maximum number of iterations for the optimizer. Default is 1000\n\n    Returns:\n        hard_iron (np.ndarray): Hard-iron offset in G\n        soft_iron (np.ndarray): Soft-iron scaling matrix\n        corrected_magnetic_field (np.ndarray): Corrected magnetic field data\n        optimization_errors (list): List of optimization errors in each iteration\n\n    Raises:\n        TypeError: If the magnetic field input is not a numpy array or a list\n        TypeError: If the reference magnetic field input is not a numpy array or a list\n        TypeError: If the rph input is not a numpy array or a list\n        ValueError: If the magnetic field input is not a 3xN or Nx3 numpy array\n        ValueError: If the reference magnetic field input is not a 3, numpy array\n        ValueError: If the rph input is not a 3xN or Nx3 numpy array\n        TypeError: If the magnetic declination is not a float\n        ValueError: If the optimizer is not a string or not \"dogleg\" or \"lm\"\n        TypeError: If the relative error tolerance is not a float\n        TypeError: If the absolute error tolerance is not a float\n        ValueError: If the maximum number of iterations is not a positive integer\n    \"\"\"\n    # Check if the magnetic field input is a list and convert it to a numpy array\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n\n    # Check if the reference magnetic field input is a list and convert it to a numpy array\n    if isinstance(reference_magnetic_field, list):\n        reference_magnetic_field = np.array(reference_magnetic_field).flatten()\n\n    # Check if the rph input is a list and convert it to a numpy array\n    if isinstance(rph, list):\n        rph = np.array(rph)\n\n    # Check if the magnetic field input is a numpy array\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field input must be a numpy array or a list.\")\n\n    # Check if the reference magnetic field input is a numpy array\n    if not isinstance(reference_magnetic_field, np.ndarray):\n        raise TypeError(\"The reference magnetic field input must be a numpy array or a list.\")\n\n    # Check if the rph input is a numpy array\n    if not isinstance(rph, np.ndarray):\n        raise TypeError(\"The rph input must be a numpy array or a list.\")\n\n    # Check if the magnetic field input is a 3xN or Nx3 numpy array\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field input must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the reference magnetic field input is a 3, numpy array\n    reference_magnetic_field = reference_magnetic_field.flatten()\n    if reference_magnetic_field.shape[0] != 3:\n        raise ValueError(\"The reference magnetic field input must be a 3, or 1x3, or 3x1 numpy array.\")\n\n    # Check if the rph input is is a 3xN or Nx3 numpy array\n    if rph.ndim != 2 or (rph.shape[0] != 3 and rph.shape[1] != 3):\n        raise ValueError(\"The rph input must be a 3xN or Nx3 numpy array.\")\n\n    # Force the magnetic field array to be a Nx3 numpy array\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n\n    # Force the rph array to be a Nx3 numpy array\n    if rph.shape[0] == 3:\n        rph = rph.T\n\n    # Check that the magnetic declination is a float\n    if not isinstance(magnetic_declination, float):\n        raise TypeError(\"The magnetic declination must be a float.\")\n\n    # Check that the optimizer is a string and is either \"dogleg\" or \"lm\"\n    if not isinstance(optimizer, str) or optimizer not in [\"dogleg\", \"lm\"]:\n        raise ValueError(\"The optimizer must be a string and either 'dogleg' or 'lm'.\")\n\n    # Check that the relative error tolerance is a float\n    if not isinstance(relative_error_tol, float) or relative_error_tol &lt;= 0:\n        raise TypeError(\"The relative error tolerance must be a float.\")\n\n    # Check that the absolute error tolerance is a float\n    if not isinstance(absolute_error_tol, float) or absolute_error_tol &lt;= 0:\n        raise TypeError(\"The absolute error tolerance must be a float.\")\n\n    # Check that the maximum number of iterations is a positive integer\n    if not isinstance(max_iter, int) or max_iter &lt;= 0:\n        raise ValueError(\"The maximum number of iterations must be a positive integer.\")\n\n    # Compute attitude based on magnetic heading\n    magnetic_hdg = _ahrs_raw_hdg(magnetic_field, rph) - np.deg2rad(magnetic_declination)\n    magnetic_rph = np.concatenate([rph[:, :2], magnetic_hdg.reshape(-1, 1)], axis=1)\n\n    # Compute calibration\n    # Smoothing and Mapping Factor Graph\n    # 1. Create the non-linear graph\n    graph = gtsam.NonlinearFactorGraph()\n\n    # 2. noise model for each factor.\n    residual_noise = gtsam.noiseModel.Isotropic.Sigma(3, 0.001)\n\n    # 3. Creates values structure with initial values: S -&gt; Scale, D -&gt; Direction, B -&gt; Bias\n    initial = gtsam.Values()\n    initial.insert(S(0), 1.0)\n    initial.insert(B(0), gtsam.Point3(0, 0, 0))\n    keys = [S(0), B(0)]\n\n    # 4. Add factor for each measurement into a single node\n    h0 = gtsam.Point3(reference_magnetic_field.flatten())\n\n    for i in range(magnetic_field.shape[0]):\n        mi = gtsam.Point3(magnetic_field[i, :])\n        bRw = gtsam.Rot3(nm.rph2rot(magnetic_rph[i, :]).T)\n\n        # 5.1 magFactor3\n        rf = gtsam.CustomFactor(residual_noise, keys, partial(_residual_factor, mi, h0, bRw))\n        graph.add(rf)\n\n    # 5. If not online optimize the full batch\n    # 5.1 Create optimizer parameters\n    params = gtsam.DoglegParams() if optimizer == \"dogleg\" else gtsam.LevenbergMarquardtParams()\n    params.setRelativeErrorTol(relative_error_tol)\n    params.setAbsoluteErrorTol(absolute_error_tol)\n    params.setMaxIterations(max_iter)\n    params.setLinearSolverType(\"MULTIFRONTAL_CHOLESKY\")\n\n    # 5.2 Create optimizer\n    if optimizer == \"dogleg\":\n        optimizer = gtsam.DoglegOptimizer(graph, initial, params)\n    else:\n        optimizer = gtsam.LevenbergMarquardtOptimizer(graph, initial, params)\n\n    # 5.3 Optimize\n    result, optimization_errors = _gtsam_optimize(optimizer, params)\n\n    # 7. Process Results\n    hard_iron = np.vstack(result.atPoint3(B(0)))\n    soft_iron = result.atDouble(S(0)) * np.eye(3)\n\n    # Correct the magnetic field\n    corrected_magnetic_field = (np.linalg.inv(soft_iron) @ (magnetic_field.T - hard_iron.reshape(3, -1))).T\n\n    return hard_iron.flatten(), soft_iron, corrected_magnetic_field, optimization_errors\n</code></pre>"},{"location":"Benchmark%20Methods/spherefit/","title":"Sphere Fit","text":"<p>MAGYC - Benchmark Methods - Sphere Fit</p> <p>This module contains sphere fit appraches for magnetometer calibration.</p> <p>Functions:</p> Name Description <code>sphere_fit</code> <p>Standard sphere fit method.</p>"},{"location":"Benchmark%20Methods/spherefit/#magyc.benchmark_methods.spherefit.sphere_fit","title":"<code>sphere_fit(magnetic_field)</code>","text":"<p>The sphere fit method fits a sphere to a collection of data using a closed form for the solution. With this purpose, propose an optimization problem that seeks to minimize the sum:</p> \\[\\sum_i ((x_i-x_c)^2+(y_i-y_c)^2+(z_i-z_c)^2-r^2)^2\\] <p>Where x, y, and z is the data; \\(x_c\\), \\(y_c\\), and \\(z_c\\) are the sphere center; and r is the radius.</p> <p>The method assumes that points are not in a singular configuration and are real numbers to solve this problem. If you have coplanar data, use a circle fit with svd for determining the plane, recommended Circle Fit (Pratt method), by Nikolai Chernov</p> <p>Inspired by Alan Jennings, University of Dayton, implementation (source)</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input is not a numpy array or a list.</p> <code>ValueError</code> <p>If the input is not a 3xN or Nx3 numpy array.</p> Source code in <code>magyc/benchmark_methods/spherefit.py</code> <pre><code>def sphere_fit(magnetic_field: Union[np.ndarray, list]) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    The sphere fit method fits a sphere to a collection of data using a closed\n    form for the solution. With this purpose, propose an optimization problem that\n    seeks to minimize the sum:\n\n    $$\\\\sum_i ((x_i-x_c)^2+(y_i-y_c)^2+(z_i-z_c)^2-r^2)^2$$\n\n    Where x, y, and z is the data; $x_c$, $y_c$, and $z_c$ are the sphere center;\n    and r is the radius.\n\n    The method assumes that points are not in a singular configuration and are\n    real numbers to solve this problem. If you have coplanar data, use a circle\n    fit with svd for determining the plane, recommended [Circle Fit (Pratt method),\n    by Nikolai Chernov](http://www.mathworks.com/matlabcentral/fileexchange/22643)\n\n    Inspired by Alan Jennings, University of Dayton, implementation ([source](\n    https://www.mathworks.com/matlabcentral/fileexchange/34129-sphere-fit-least-squared))\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements\n\n    Raises:\n        TypeError: If the input is not a numpy array or a list.\n        ValueError: If the input is not a 3xN or Nx3 numpy array.\n    \"\"\"\n    # Check if the input is a list and convert it to a numpy array\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n\n    # Check if the input is a numpy array\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The input must be a numpy array or a list.\")\n\n    # Check if the input is a 3xN or Nx3 numpy array\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The input must be a 3xN or Nx3 numpy array.\")\n\n    # Force the array to be a Nx3 numpy array\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n\n    # Compute magnetic field calibration\n    mf = magnetic_field\n    a_matrix = np.array(\n        [\n            [\n                np.mean(mf[:, 0] * (mf[:, 0] - np.mean(mf[:, 0]))),\n                2 * np.mean(mf[:, 0] * (mf[:, 1] - np.mean(mf[:, 1]))),\n                2 * np.mean(mf[:, 0] * (mf[:, 2] - np.mean(mf[:, 2]))),\n            ],\n            [\n                0,\n                np.mean(mf[:, 1] * (mf[:, 1] - np.mean(mf[:, 1]))),\n                2 * np.mean(mf[:, 1] * (mf[:, 2] - np.mean(mf[:, 2]))),\n            ],\n            [0, 0, np.mean(mf[:, 2] * (mf[:, 2] - np.mean(mf[:, 2])))],\n        ]\n    )\n\n    a_matrix = a_matrix + a_matrix.T\n    b_matrix = np.array(\n        [\n            [np.mean((mf[:, 0] ** 2 + mf[:, 1] ** 2 + mf[:, 2] ** 2) * (mf[:, 0] - np.mean(mf[:, 0])))],\n            [np.mean((mf[:, 0] ** 2 + mf[:, 1] ** 2 + mf[:, 2] ** 2) * (mf[:, 1] - np.mean(mf[:, 1])))],\n            [np.mean((mf[:, 0] ** 2 + mf[:, 1] ** 2 + mf[:, 2] ** 2) * (mf[:, 2] - np.mean(mf[:, 2])))],\n        ]\n    )\n\n    hard_iron = np.array(np.linalg.lstsq(a_matrix, b_matrix, rcond=None)[0])\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = magnetic_field - hard_iron.flatten()\n\n    return hard_iron.flatten(), calibrated_magnetic_field\n</code></pre>"},{"location":"Benchmark%20Methods/twostep/","title":"TWOSTEP","text":"<p>The TWOSTEP method proposes a fast, robust algorithm for estimating magnetometer biases when the attitude is unknown. This algorithm combines the convergence in a single step of a heuristic algorithm currently in use with the correct treatment of the statistics of the measurements and does without discarding data.</p> <p>This algorithm was the in a first publication developed for the estimation of the hard-iron (Alonso, R. Shuster, M.D. (2002a). TWOSTEP: A fast, robust algorithm for attitude-independent magnetometer-bias determination. Journal of the Astronautical Sciences, 50(4):433-452.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>reference_magnetic_field</code> <code>ndarray or list</code> <p>Reference magnetic field measurements in a 3, or 1x3, or 3x1 numpy array or list.</p> required <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations for the second step.</p> <code>2000</code> <code>measurement_noise_std</code> <code>float</code> <p>Standard deviation that characterizes the measurements' noise, by default 0.001 G.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Estimated hard-iron bias as a 3x1 numpy array.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field as a 3xN numpy array.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field or reference magnetic field inputs are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field input is not a 3xN or Nx3 numpy array, if the reference magnetic field input is not a 3, or 1x3, or 3x1 numpy array, if the maximum number of iterations is not a positive integer, or if the measurement noise standard deviation is not a positive float.</p> Source code in <code>magyc/benchmark_methods/twostep.py</code> <pre><code>def twostep_hi(magnetic_field: Union[np.ndarray, list], reference_magnetic_field: Union[np.ndarray, list],\n               max_iterations: int = 2000, measurement_noise_std: float = 1e-3) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    The TWOSTEP method proposes a fast, robust algorithm for estimating magnetometer\n    biases when the attitude is unknown. This algorithm combines the convergence\n    in a single step of a heuristic algorithm currently in use with the correct\n    treatment of the statistics of the measurements and does without discarding\n    data.\n\n    This algorithm was the in a first publication developed for the estimation of\n    the hard-iron (Alonso, R. Shuster, M.D. (2002a). TWOSTEP: A fast, robust\n    algorithm for attitude-independent magnetometer-bias determination. Journal\n    of the Astronautical Sciences, 50(4):433-452.\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        reference_magnetic_field (numpy.ndarray or list): Reference magnetic field\n            measurements in a 3, or 1x3, or 3x1 numpy array or list.\n        max_iterations (int): Maximum number of iterations for the second step.\n        measurement_noise_std (float): Standard deviation that characterizes the\n            measurements' noise, by default 0.001 G.\n\n    Returns:\n        hard_iron (numpy.ndarray): Estimated hard-iron bias as a 3x1 numpy array.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field as a\n            3xN numpy array.\n\n    Raises:\n        TypeError: If the magnetic field or reference magnetic field inputs are not\n            numpy arrays or lists.\n        ValueError: If the magnetic field input is not a 3xN or Nx3 numpy array, if\n            the reference magnetic field input is not a 3, or 1x3, or 3x1 numpy array,\n            if the maximum number of iterations is not a positive integer, or if the\n            measurement noise standard deviation is not a positive float.\n    \"\"\"\n    # Check if the magnetic field input is a list and convert it to a numpy array\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n\n    # Check if the reference magnetic field input is a list and convert it to a numpy array\n    if isinstance(reference_magnetic_field, list):\n        reference_magnetic_field = np.array(reference_magnetic_field).flatten()\n\n    # Check if the magnetic field input is a numpy array\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field input must be a numpy array or a list.\")\n\n    # Check if the reference magnetic field input is a numpy array\n    if not isinstance(reference_magnetic_field, np.ndarray):\n        raise TypeError(\"The reference magnetic field input must be a numpy array or a list.\")\n\n    # Check if the magnetic field input is a 3xN or Nx3 numpy array\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field input must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the reference magnetic field input is a 3, numpy array\n    if reference_magnetic_field.ndim != 1 and reference_magnetic_field.size != 3:\n        raise ValueError(\"The reference magnetic field input must be a 3, or 1x3, or 3x1 numpy array.\")\n\n    # Force the magnetic field array to be a Nx3 numpy array\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n\n    # Check that the maximum number of iterations is a positive integer\n    if not isinstance(max_iterations, int) or max_iterations &lt;= 0:\n        raise ValueError(\"The maximum number of iterations must be a positive integer.\")\n\n    # Check that the measurement noise standard deviation is a positive float\n    if not isinstance(measurement_noise_std, float) or measurement_noise_std &lt;= 0:\n        raise ValueError(\"The measurement noise standard deviation must be a positive float.\")\n\n    # Compute magnetic field calibration\n    mf = magnetic_field\n\n    # First step\n    b0 = np.zeros((3, 1))\n\n    # Effective measurement from paper equation (3a)\n    b_matrix = np.ones((mf.shape)) * reference_magnetic_field\n    z_k = (np.square(np.linalg.norm(mf, axis=1)) - np.square(np.linalg.norm(b_matrix, axis=1))).reshape(-1, 1)\n\n    # Sensor measurements noise modeled as white gaussian with standard deviation epsilon_k\n    epsilon_sq_k = np.ones(mf.shape) * (measurement_noise_std**2)\n\n    # Sensor error scalar measurement noise characterization as gaussian.\n    # Gaussian distribution mean, equation (7a)\n    mu_k = -np.sum(epsilon_sq_k, axis=1, keepdims=True)\n\n    # Gaussian distribution variance, equation (5.15)\n    sigma_sq_k = (\n        4\n        * (\n            (mf.reshape(-1, 1, 3) - b0.reshape(1, 3))\n            @ np.apply_along_axis(np.diag, 1, epsilon_sq_k)\n            @ (mf.reshape(-1, 3, 1) - b0)\n        )\n        + 2 * np.apply_along_axis(lambda x: np.square(np.trace(np.diag(x))), 1, epsilon_sq_k).reshape(-1, 1, 1)\n    ).reshape(-1, 1)\n\n    # Calculate  centered sigma squared, equation (14)\n    sigma_sq_bar = 1 / np.sum(1 / sigma_sq_k)\n\n    # Center  the  data\n    mu_bar, mu_k_tilde = _center_data(mu_k, sigma_sq_k, sigma_sq_bar)\n    z_bar, z_k_tilde = _center_data(z_k, sigma_sq_k, sigma_sq_bar)\n    b_bar, b_k_tilde = _center_data(b_matrix, sigma_sq_k, sigma_sq_bar)\n\n    # Offset and error covariance matrix calculation from paper equations (33) and (34)\n    F_bb_tilde = np.einsum(\n        \"ijk-&gt;jk\",\n        (4 / sigma_sq_k.reshape(-1, 1, 1)) * (b_k_tilde.reshape(-1, 3, 1) @ b_k_tilde.reshape(-1, 1, 3)),\n    )\n    F_zb = np.einsum(\n        \"ijk-&gt;jk\",\n        ((z_k_tilde - mu_k_tilde) * (2 / sigma_sq_k)).reshape(-1, 1, 1) * b_k_tilde.reshape(-1, 3, 1),\n    )\n    b = np.linalg.inv(F_bb_tilde) @ F_zb\n\n    # Second Step: Iterative\n    F_bb_bar = (4 / sigma_sq_bar) * (b_bar.reshape(-1, 1) - b) @ (b_bar.reshape(-1, 1) - b).T\n    b_asterisk = np.copy(b)\n\n    if np.max(np.diag(F_bb_bar) / np.diag(F_bb_tilde)) &gt; 0.001:\n        F_bb = F_bb_tilde + F_bb_bar\n        gg = (F_bb_tilde @ (b - b_asterisk)) - (1 / sigma_sq_bar) * (\n            z_bar - 2 * (b_bar @ b) + np.linalg.norm(b) ** 2 - mu_bar\n        ) * 2 * (b_bar.reshape(-1, 1) - b)\n        bn = b - np.linalg.inv(F_bb) @ gg\n\n        iter = 1\n        while ((bn - b).T @ F_bb @ (bn - b)) &gt; 0.001:\n            b = np.copy(bn)\n            gg = (F_bb_tilde @ (b - b_asterisk)) - (1 / sigma_sq_bar) * (\n                z_bar - 2 * (b_bar @ b) + np.linalg.norm(b) ** 2 - mu_bar\n            ) * 2 * (b_bar.reshape(-1, 1) - b)\n            F_bb_bar = (4 / sigma_sq_bar) * (b_bar.reshape(-1, 1) - b) @ (b_bar.reshape(-1, 1) - b).T\n            F_bb = F_bb_tilde + F_bb_bar\n            bn = b - np.linalg.inv(F_bb) @ gg\n\n            iter += 1\n            if iter &gt; max_iterations:\n                warnings.warn(\"Second step: Maximum number of iterations reached.\", RuntimeWarning)\n                break\n\n    hard_iron = bn.reshape(3, 1)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = magnetic_field - hard_iron.flatten()\n\n    return hard_iron.flatten(), calibrated_magnetic_field\n</code></pre> <p>The TWOSTEP method proposes a fast, robust algorithm for estimating magnetometer biases when the attitude is unknown. This algorithm combines the convergence in a single step of a heuristic algorithm currently in use with the correct treatment of the statistics of the measurements and does without discarding data.</p> <p>This algorithm was extended in a second iteration to compute also the soft-iron (Alonso, R. Shuster, M.D. (2002b). Complete linear attitude-independent magnetometer calibration. Journal of the Astronautical Science, 50(4):477-490).</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>reference_magnetic_field</code> <code>ndarray or list</code> <p>Reference magnetic field measurements in a 3, or 1x3, or 3x1 numpy array or list.</p> required <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations for the second step.</p> <code>2000</code> <code>measurement_noise_std</code> <code>float</code> <p>Standard deviation that characterizes the measurements' noise, by default 0.001 G.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Estimated hard-iron bias as a 3x1 numpy array.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field as a 3xN numpy array.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field or reference magnetic field inputs are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field input is not a 3xN or Nx3 numpy array, if the reference magnetic field input is not a 3, or 1x3, or 3x1 numpy array, if the maximum number of iterations is not a positive integer, or if the measurement noise standard deviation is not a positive float.</p> Source code in <code>magyc/benchmark_methods/twostep.py</code> <pre><code>def twostep_hsi(magnetic_field: Union[np.ndarray, list], reference_magnetic_field: Union[np.ndarray, list],\n                max_iterations: int = 2000, measurement_noise_std: float = 1e-3) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    The TWOSTEP method proposes a fast, robust algorithm for estimating magnetometer\n    biases when the attitude is unknown. This algorithm combines the convergence\n    in a single step of a heuristic algorithm currently in use with the correct\n    treatment of the statistics of the measurements and does without discarding\n    data.\n\n    This algorithm was extended in a second iteration to compute also the soft-iron\n    (Alonso, R. Shuster, M.D. (2002b). Complete linear attitude-independent\n    magnetometer calibration. Journal of the Astronautical Science, 50(4):477-490).\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        reference_magnetic_field (numpy.ndarray or list): Reference magnetic field\n            measurements in a 3, or 1x3, or 3x1 numpy array or list.\n        max_iterations (int): Maximum number of iterations for the second step.\n        measurement_noise_std (float): Standard deviation that characterizes the\n            measurements' noise, by default 0.001 G.\n\n    Returns:\n        hard_iron (numpy.ndarray): Estimated hard-iron bias as a 3x1 numpy array.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field as a\n            3xN numpy array.\n\n    Raises:\n        TypeError: If the magnetic field or reference magnetic field inputs are not\n            numpy arrays or lists.\n        ValueError: If the magnetic field input is not a 3xN or Nx3 numpy array, if\n            the reference magnetic field input is not a 3, or 1x3, or 3x1 numpy array,\n            if the maximum number of iterations is not a positive integer, or if the\n            measurement noise standard deviation is not a positive float.\n    \"\"\"\n    # Check if the magnetic field input is a list and convert it to a numpy array\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n\n    # Check if the reference magnetic field input is a list and convert it to a numpy array\n    if isinstance(reference_magnetic_field, list):\n        reference_magnetic_field = np.array(reference_magnetic_field).flatten()\n\n    # Check if the magnetic field input is a numpy array\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field input must be a numpy array or a list.\")\n\n    # Check if the reference magnetic field input is a numpy array\n    if not isinstance(reference_magnetic_field, np.ndarray):\n        raise TypeError(\"The reference magnetic field input must be a numpy array or a list.\")\n\n    # Check if the magnetic field input is a 3xN or Nx3 numpy array\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field input must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the reference magnetic field input is a 3, numpy array\n    if reference_magnetic_field.ndim != 1 and reference_magnetic_field.size != 3:\n        raise ValueError(\"The reference magnetic field input must be a 3, or 1x3, or 3x1 numpy array.\")\n\n    # Force the magnetic field array to be a Nx3 numpy array\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n\n    # Check that the maximum number of iterations is a positive integer\n    if not isinstance(max_iterations, int) or max_iterations &lt;= 0:\n        raise ValueError(\"The maximum number of iterations must be a positive integer.\")\n\n    # Check that the measurement noise standard deviation is a positive float\n    if not isinstance(measurement_noise_std, float) or measurement_noise_std &lt;= 0:\n        raise ValueError(\"The measurement noise standard deviation must be a positive float.\")\n\n    # Compute magnetic field calibration\n    mf = magnetic_field\n\n    stop_tol = 1e-24  # Stop Condition from Alonso paper\n    I3 = np.eye(3, dtype=np.float64)\n\n    # TWOSTEP Centered estimate\n    # Set initial guess for b and D.\n    b0 = np.zeros((3, 1))\n    d0 = np.zeros((3, 3))\n\n    # Form L matrix, equations (5.10b) and (5.12a)\n    l1 = 2 * mf\n    l2 = -np.square(mf)\n    l3 = -2 * mf[:, [0]] * mf[:, [1]]\n    l4 = -2 * mf[:, [0]] * mf[:, [2]]\n    l5 = -2 * mf[:, [1]] * mf[:, [2]]\n    L_k = np.concatenate([l1, l2, l3, l4, l5], axis=1)\n\n    # Compute sensor error as scalar measurement, equation (5.7a)\n    h_matrix = np.ones((mf.shape)) * reference_magnetic_field\n    z_k = (np.square(np.linalg.norm(mf, axis=1)) - np.square(np.linalg.norm(h_matrix, axis=1))).reshape(-1, 1)\n\n    # Sensor measurements noise modeled as white gaussian with standard deviation epsilon_k\n    epsilon_sq_k = np.ones(mf.shape) * (measurement_noise_std**2)\n\n    # Sensor error scalar measurement noise characterization as gaussian.\n    # Gaussian distribution mean, equation (5.14)\n    mu_k = -np.sum(epsilon_sq_k, axis=1, keepdims=True)\n\n    # Gaussian distribution variance, equation (5.15)\n    sigma_sq_k = (\n        4\n        * np.einsum(\n            \"ijk-&gt;ikj\",\n            np.tile(I3 + d0, (mf.shape[0], 1, 1)) @ mf.reshape(-1, 3, 1) - np.tile(b0, (mf.shape[0], 1, 1)),\n        )\n        @ np.apply_along_axis(np.diag, 1, epsilon_sq_k)\n        @ (np.tile(I3 + d0, (mf.shape[0], 1, 1)) @ mf.reshape(-1, 3, 1) - np.tile(b0, (mf.shape[0], 1, 1)))\n        + 2 * np.apply_along_axis(lambda x: np.square(np.trace(np.diag(x))), 1, epsilon_sq_k).reshape(-1, 1, 1)\n    ).reshape(-1, 1)\n\n    # Calculate centered sigma squared, equation (5.18)\n    sigma_sq_bar = 1 / np.sum(1 / sigma_sq_k)\n\n    # Center the data, equation (5.19)\n    mu_bar, mu_k_tilde = _center_data(mu_k, sigma_sq_k, sigma_sq_bar)\n    z_bar, z_k_tilde = _center_data(z_k, sigma_sq_k, sigma_sq_bar)\n    L_bar, L_k_tilde = _center_data(L_k, sigma_sq_k, sigma_sq_bar)\n\n    # Compute fisher information matrix\n    I_fisher_tilde, I_fishinv_tilde = _TS_fisher_centered(sigma_sq_k, L_k_tilde)\n\n    # Compute centered estimate, equation (5.24)\n    f_matrix = np.einsum(\n        \"ijk-&gt;jk\",\n        (\n            (1 / sigma_sq_k).reshape(-1, 1, 1)\n            * ((z_k_tilde - mu_k_tilde).reshape(-1, 1, 1) * L_k_tilde.reshape(-1, 9, 1))\n        ),\n    )\n    theta_0_tilde = I_fishinv_tilde @ f_matrix\n\n    # TWOSTEP Center correction\n    theta_n, theta_np1 = theta_0_tilde, theta_0_tilde  # Initiate theta for  first  iteration\n    n = 0  # Initialise  iteration counter\n    TS_err = np.Inf  # Initial  condition  for  error.\n\n    # ABC is used to remove intensive calculations out of for loop\n    abc = -np.einsum(\n        \"ijk-&gt;jk\",\n        (\n            (1 / sigma_sq_k).reshape(-1, 1, 1)\n            * ((z_k_tilde - mu_k_tilde).reshape(-1, 1, 1) * L_k_tilde.reshape(-1, 9, 1))\n        ),\n    )\n\n    while TS_err &gt; stop_tol and n &lt; max_iterations:\n        if n != 0:  # If  we are not  in the first\titeration\n            theta_n = theta_np1\n\n        # Extract  c  and  E  components\n        c, e_matrix = _theta_to_c_E(theta_n)\n\n        # Compute  second  derivative  of  b^2  wrt theta\n        tmp = np.linalg.solve((np.eye(3) + e_matrix), c) @ np.linalg.solve((np.eye(3) + e_matrix), c).T\n        dbsqdtheta_p = np.concatenate(\n            [\n                2 * np.linalg.solve((np.eye(3) + e_matrix), c),\n                -np.diag(tmp).reshape(3, 1),\n                np.vstack([-2 * tmp[0, 1], -2 * tmp[0, 2], -2 * tmp[1, 2]]),\n            ]\n        )\n        # Compute gradient of J\n        dJdThetap_tilde = abc + I_fisher_tilde @ theta_n\n        dJdThetap_bar = (\n            -(1 / sigma_sq_bar)\n            * (L_bar.reshape(-1, 1) - dbsqdtheta_p)\n            * (z_bar - (L_bar.reshape(1, -1) @ theta_n) + (c.T @ np.linalg.solve((np.eye(3) + e_matrix), c)) - mu_bar)\n        )\n        dJdTheta = dJdThetap_tilde + dJdThetap_bar\n\n        # Calculate Fisher matrix\n        I_fisher_bar = _TS_fisher_center(sigma_sq_bar, L_bar, dbsqdtheta_p)\n\n        # Update theta\n        theta_np1 = theta_n - np.linalg.solve((I_fisher_tilde + I_fisher_bar), dJdTheta)\n\n        # Compute error\n        TS_err = ((theta_np1 - theta_n).T @ (I_fisher_tilde + I_fisher_bar)) @ (theta_np1 - theta_n)\n        n += 1\n\n    b, d_matrix = _theta_to_b_D(theta_np1)\n\n    # Extract covariance matrix\n    m_cd = np.array(\n        [\n            [b[0, 0], 0, 0, b[1, 0], b[2, 0], 0],\n            [0, b[1, 0], 0, b[0, 0], 0, b[2, 0]],\n            [0, 0, b[2, 0], 0, b[0, 0], b[1, 0]],\n        ]\n    )\n    m_ed = np.array(\n        [\n            [2 * d_matrix[0, 0], 0, 0, 2 * d_matrix[0, 1], 2 * d_matrix[0, 2], 0],\n            [0, 2 * d_matrix[1, 1], 0, 2 * d_matrix[0, 1], 0, 2 * d_matrix[1, 2]],\n            [0, 0, 2 * d_matrix[2, 2], 0, 2 * d_matrix[0, 2], 2 * d_matrix[1, 2]],\n            [d_matrix[0, 1], d_matrix[0, 1], 0, d_matrix[0, 0] + d_matrix[1, 1], d_matrix[1, 2], d_matrix[0, 2]],\n            [d_matrix[0, 2], 0, d_matrix[0, 2], d_matrix[1, 2], d_matrix[0, 0] + d_matrix[2, 2], d_matrix[0, 1]],\n            [0, d_matrix[1, 2], d_matrix[1, 2], d_matrix[0, 2], d_matrix[0, 1], d_matrix[1, 1] + d_matrix[2, 2]],\n        ]\n    )\n    dbD_dcE = np.eye(9)\n    dbD_dcE[:3, :3], dbD_dcE[:3, 3:] = np.eye(3) + d_matrix, m_cd\n    dbD_dcE[3:, :3], dbD_dcE[3:, 3:] = np.zeros((6, 3)), 2 * np.eye(6) @ m_ed\n    dbD_dcE = np.linalg.inv(dbD_dcE)\n    # Cov_est = dbD_dcE @ np.linalg.solve((I_fisher_tilde + I_fisher_bar), dbD_dcE.T)\n\n    # END   TWOSTEP\n    hard_iron = (np.linalg.inv(np.eye(3) + d_matrix)) @ b\n    soft_iron = np.linalg.inv(np.eye(3) + d_matrix)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = (np.linalg.inv(soft_iron) @ (magnetic_field.reshape(3, -1) - hard_iron.reshape(3, 1))).T\n\n    return hard_iron.flatten(), soft_iron, calibrated_magnetic_field\n</code></pre>"},{"location":"License/license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Sebasti\u00e1n An\u00edbal Rodr\u00edguez Mart\u00ednez</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"Plots/3d_magnetic_field_plot/","title":"3D Magnetic Field Plot","text":"<p>Plots the data of a data set given the magnetic field. The components of the plot are the original magnetic field represented with a black cage, the distorted magnetic plot as an orange cage, and the samples of the magnetic field as blue dots.</p> <p>Parameters:</p> Name Type Description Default <code>soft_iron</code> <code>ndarray</code> <p>Soft-iron matrix as a (3, 3) numpy array.</p> required <code>hard_iron</code> <code>ndarray</code> <p>Hard-iron matrix as a (3, 1) numpy array.</p> required <code>magnetic_field</code> <code>ndarray</code> <p>Magnetic field in G as a (n, 3) numpy array.</p> required <code>local_magnetic_field</code> <code>ndarray</code> <p>Local magnetic field in G as a (3, ) numpy array.</p> required <code>save</code> <code>str</code> <p>Directory to save the plots as a string.</p> <code>''</code> Source code in <code>magyc/plots/plots.py</code> <pre><code>def magfield_data_plot(soft_iron: np.ndarray, hard_iron: np.ndarray, magnetic_field: np.ndarray,\n                       local_magnetic_field: np.ndarray, save: str = \"\") -&gt; None:\n    \"\"\"\n    Plots the data of a data set given the magnetic field. The components of the\n    plot are the original magnetic field represented with a black cage, the\n    distorted magnetic plot as an orange cage, and the samples of the magnetic\n    field as blue dots.\n\n    Args:\n        soft_iron (np.ndarray): Soft-iron matrix as a (3, 3) numpy array.\n        hard_iron (np.ndarray): Hard-iron matrix as a (3, 1) numpy array.\n        magnetic_field (np.ndarray): Magnetic field in G as a (n, 3) numpy array.\n        local_magnetic_field (np.ndarray): Local magnetic field in G as a (3, ) numpy array.\n        save (str): Directory to save the plots as a string.\n    \"\"\"\n    # Sphere radius\n    r = np.linalg.norm(local_magnetic_field)\n\n    # Create Figure\n    fig = plt.figure(figsize=(9, 9))\n    ax = fig.add_subplot(111, projection=\"3d\")\n\n    # Remove background and axes\n    fig.patch.set_facecolor('none')\n    ax.set_axis_off()\n    ax.spines['top'].set_color('none')\n    ax.spines['bottom'].set_color('none')\n    ax.spines['left'].set_color('none')\n    ax.spines['right'].set_color('none')\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Get color palette\n    colors = _get_color_palette()\n\n    # Plot the magnetic field measurements with decreased amount of samples\n    magnetic_field = magnetic_field[::5, :]\n    ax.scatter(magnetic_field[:, 0], magnetic_field[:, 1], magnetic_field[:, 2], marker=\".\",\n               color=colors[\"Midnight Green\"])\n\n    # Plot the disturbed magnetic field\n    ellipsoid_plot(hard_iron.flatten(), [r, r, r], soft_iron, ax=ax, plot_axes=True,\n                   cage_color=colors[\"Alloy Orange\"], cage_alpha=0.4)\n\n    # Plot the corrected magnetic field\n    ellipsoid_plot([0, 0, 0], [r, r, r], np.eye(3), ax=ax, plot_axes=True, cage_color=colors[\"Rich Black\"])\n\n    # Set axes fro equal ratios\n    ax.set_box_aspect([1, 1, 1])\n    limits = np.array([ax.get_xlim3d(), ax.get_ylim3d(), ax.get_zlim3d()])\n    x, y, z = np.mean(limits, axis=1)\n    radius = 0.29 * np.max(np.abs(limits[:, 1] - limits[:, 0]))\n    ax.set_xlim3d([x - radius, x + radius])\n    ax.set_ylim3d([y - radius, y + radius])\n    ax.set_zlim3d([z - radius, z + radius])\n\n    # Set view angle to 210, best angle to see the ellipsoid with respect to the sphere.\n    ax.view_init(30, 210)\n\n    # Show the plot or save the plot given the save parameter.\n    plt.tight_layout()\n    if save:\n        # plt.savefig(save, format=\"pdf\")\n        plt.savefig(\".\".join([save.split(\".\")[0], \"png\"]))\n    else:\n        plt.show()\n    plt.close()\n</code></pre>"},{"location":"Proposed%20Methods/magyc_bfg/","title":"MAGYC-BFG","text":"<p>Proposed method for the full calibration of a three-axis magnetometer using magnetic field and angular rate measurements. This particular approach is based on a factor graph processing all the data in a batch manner.</p> <p>In particular MAGYC-BFG embeds the volume constraint for the soft-iron into a reparametrization for the Cholesky decomposition of the soft-iron matrix, allowing for the use of half the factors.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>angular_rate</code> <code>ndarray or list</code> <p>Angular rate measurements in a 3xN or Nx3 numpy array or list.</p> required <code>time</code> <code>ndarray or list</code> <p>Time stamps of the measurements.</p> required <code>measurements_window</code> <code>int</code> <p>Window size for the measurements.</p> <code>25</code> <code>optimizer</code> <code>str</code> <p>Optimization algorithm to use. Options are \"dogleg\" or \"lm\" for the Dogleg and Levenberg-Marquardt optimizers respectively.</p> <code>'dogleg'</code> <code>relative_error_tol</code> <code>float</code> <p>Relative error tolerance for the optimizer. Default is 1.00e-07</p> <code>1e-07</code> <code>absolute_error_tol</code> <code>float</code> <p>Absolute error tolerance for the optimizer. Default is 1.00e-07</p> <code>1e-07</code> <code>max_iter</code> <code>int</code> <p>Maximum number of iterations for the optimizer. Default is 1000</p> <code>1000</code> <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>soft_iron</code> <code>ndarray</code> <p>Soft iron matrix.</p> <code>gyro_bias</code> <code>ndarray</code> <p>Gyroscope bias.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements.</p> <code>calibrated_angular_rate</code> <code>ndarray</code> <p>Calibrated angular rate measurements.</p> <code>optimization_status</code> <code>Dict[str, Union[List[float], int]]</code> <p>Dictionary with the optimization status. The keys are \"error\" and \"iterations\".</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field, angular rate, and time are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field and angular rate are not 3xN or Nx3 numpy arrays, or if the time is not a 1D numpy array.</p> <code>ValueError</code> <p>If the optimizer is not a string or not \"dogleg\" or \"lm\"</p> <code>TypeError</code> <p>If the relative error tolerance is not a float</p> <code>TypeError</code> <p>If the absolute error tolerance is not a float</p> <code>ValueError</code> <p>If the maximum number of iterations is not a positive integer</p> <code>ValueError</code> <p>If the measurements window is not a positive integer</p> Source code in <code>magyc/methods/magyc.py</code> <pre><code>def magyc_bfg(magnetic_field: Union[np.ndarray, list], angular_rate: Union[np.ndarray, list],\n              time: Union[np.ndarray, list], measurements_window: int = 25, optimizer: str = \"dogleg\",\n              relative_error_tol: float = 1.00e-07, absolute_error_tol: float = 1.00e-07,\n              max_iter: int = 1000) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray,\n                                             Dict[str, Union[List[float], int]]]:\n    \"\"\"\n    Proposed method for the full calibration of a three-axis magnetometer\n    using magnetic field and angular rate measurements. This particular approach\n    is based on a factor graph processing all the data in a batch manner.\n\n    In particular MAGYC-BFG embeds the volume constraint for the soft-iron into\n    a reparametrization for the Cholesky decomposition of the soft-iron matrix,\n    allowing for the use of half the factors.\n\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        angular_rate (numpy.ndarray or list): Angular rate measurements in a 3xN or\n            Nx3 numpy array or list.\n        time (numpy.ndarray or list): Time stamps of the measurements.\n        measurements_window (int): Window size for the measurements.\n        optimizer (str): Optimization algorithm to use. Options are \"dogleg\" or \"lm\"\n            for the Dogleg and Levenberg-Marquardt optimizers respectively.\n        relative_error_tol (float): Relative error tolerance for the optimizer. Default is 1.00e-07\n        absolute_error_tol (float): Absolute error tolerance for the optimizer. Default is 1.00e-07\n        max_iter (int): Maximum number of iterations for the optimizer. Default is 1000\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        soft_iron (numpy.ndarray): Soft iron matrix.\n        gyro_bias (numpy.ndarray): Gyroscope bias.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements.\n        calibrated_angular_rate (numpy.ndarray): Calibrated angular rate measurements.\n        optimization_status (Dict[str, Union[List[float], int]]): Dictionary with\n            the optimization status. The keys are \"error\" and \"iterations\".\n\n    Raises:\n        TypeError: If the magnetic field, angular rate, and time are not numpy arrays or lists.\n        ValueError: If the magnetic field and angular rate are not 3xN or Nx3 numpy\n            arrays, or if the time is not a 1D numpy array.\n        ValueError: If the optimizer is not a string or not \"dogleg\" or \"lm\"\n        TypeError: If the relative error tolerance is not a float\n        TypeError: If the absolute error tolerance is not a float\n        ValueError: If the maximum number of iterations is not a positive integer\n        ValueError: If the measurements window is not a positive integer\n    \"\"\"\n    # Check if the magnetic_field, angular_rate, and time are lists and convert them to numpy arrays\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n    if isinstance(angular_rate, list):\n        angular_rate = np.array(angular_rate)\n    if isinstance(time, list):\n        time = np.array(time)\n\n    # Check if the magnetic_field, angular_rate, and time are numpy arrays\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field must be a numpy array or a list.\")\n    if not isinstance(angular_rate, np.ndarray):\n        raise TypeError(\"The angular rate must be a numpy array or a list.\")\n    if not isinstance(time, np.ndarray):\n        raise TypeError(\"The time must be a numpy array or a list.\")\n\n    # Check if the magnetic_field and angular_rate are 3xN or Nx3 numpy arrays\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field must be a 3xN or Nx3 numpy array.\")\n    if angular_rate.ndim != 2 or (angular_rate.shape[0] != 3 and angular_rate.shape[1] != 3):\n        raise ValueError(\"The angular rate must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the time is a 1D numpy array\n    time = time.flatten()\n    if time.ndim != 1:\n        raise ValueError(\"The time must be a (n, ), (n, 1) or (1, n) numpy array.\")\n\n    # Force the magnetic_field and angular_rate to be Nx3 numpy arrays\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n    if angular_rate.shape[0] == 3:\n        angular_rate = angular_rate.T\n\n    # Check if the magnetic_field, angular_rate, and time have the same number of samples\n    if magnetic_field.shape[0] != angular_rate.shape[0] or magnetic_field.shape[0] != time.shape[0]:\n        raise ValueError(\"The magnetic field, angular rate, and time must have the same number of samples.\")\n\n    # Check that the optimizer is a string and is either \"dogleg\" or \"lm\"\n    if not isinstance(optimizer, str) or optimizer not in [\"dogleg\", \"lm\"]:\n        raise ValueError(\"The optimizer must be a string and either 'dogleg' or 'lm'.\")\n\n    # Check that the relative error tolerance is a float\n    if not isinstance(relative_error_tol, float) or relative_error_tol &lt;= 0:\n        raise TypeError(\"The relative error tolerance must be a float.\")\n\n    # Check that the absolute error tolerance is a float\n    if not isinstance(absolute_error_tol, float) or absolute_error_tol &lt;= 0:\n        raise TypeError(\"The absolute error tolerance must be a float.\")\n\n    # Check that the maximum number of iterations is a positive integer\n    if not isinstance(max_iter, int) or max_iter &lt;= 0:\n        raise ValueError(\"The maximum number of iterations must be a positive integer.\")\n\n    # Check that the measurements window is a positive integer\n    if not isinstance(measurements_window, int) or measurements_window &lt;= 0:\n        raise ValueError(\"The measurements window must be a positive integer.\")\n\n    # Compute the magnetic field derivative\n    magnetic_field_derivative = np.diff(magnetic_field, axis=0) / np.diff(time).reshape(-1, 1)\n    magnetic_field_derivative = np.concatenate([np.zeros((1, 3)), magnetic_field_derivative], axis=0)\n\n    # Compute the magnetic calibration\n    # Smoothing and Mapping Factor Graph\n    # 1. Create the non-linear graph\n    graph = gtsam.NonlinearFactorGraph()\n\n    # 2. noise model for each factor.\n    residual_noise = gtsam.noiseModel.Isotropic.Sigma(3, 1e-6)\n\n    # 3. Creates values structure with initial values\n    initial = gtsam.Values()\n    initial.insert(S(0), np.array([0.0, 0.0, 0.0, 0.0, 0.0]))\n    initial.insert(B(0), gtsam.Point3(0, 0, 0))\n    initial.insert(W(0), gtsam.Point3(0, 0, 0))\n    keys = [S(0), B(0), W(0)]\n\n    # 4. Add factor for each measurement accumulates in the measurements window into a single node\n    measurements_window = int(measurements_window)\n    m_dot_window = np.empty((measurements_window, 3))\n    m_window = np.empty((measurements_window, 3))\n    w_window = np.empty((measurements_window, 3))\n\n    # 5. Add factors to the graph\n    for i in range(magnetic_field.shape[0]):\n        # Get sensor measurements and estimated magnetic field derivative\n        m_dot_window[i % measurements_window, :] = magnetic_field_derivative[i, :]\n        m_window[i % measurements_window, :] = magnetic_field[i, :]\n        w_window[i % measurements_window, :] = angular_rate[i, :]\n\n        if (i % measurements_window == 0 and i != 0):\n            # Average measurements by the measurements window size.\n            m_dot_meadian = np.median(m_dot_window, axis=0).reshape(3, 1)\n            m_median = np.median(m_window, axis=0).reshape(3, 1)\n            w_median = np.median(w_window, axis=0).reshape(3, 1)\n\n            # 5.1 Residual factor\n            rf = gtsam.CustomFactor(residual_noise, keys, partial(_residual_factor, m_dot_meadian, m_median, w_median))\n            graph.push_back(rf)\n\n            # 5.2 Reset the measurements window\n            m_dot_window = np.empty((measurements_window, 3))\n            m_window = np.empty((measurements_window, 3))\n            w_window = np.empty((measurements_window, 3))\n\n    # 6. Optimize the graph\n    # 6.1 Create optimizer parameters\n    params = gtsam.DoglegParams() if optimizer == \"dogleg\" else gtsam.LevenbergMarquardtParams()\n    params.setRelativeErrorTol(relative_error_tol)\n    params.setAbsoluteErrorTol(absolute_error_tol)\n    params.setMaxIterations(max_iter)\n    params.setLinearSolverType(\"MULTIFRONTAL_CHOLESKY\")\n\n    # For dogleg method set the trust region. For good estimations, it ranges between 0.1 and 1.0\n    if optimizer == \"dogleg\":\n        params.setDeltaInitial(0.5)\n\n    # 6.2 Create optimizer\n    if optimizer == \"dogleg\":\n        optimizer = gtsam.DoglegOptimizer(graph, initial, params)\n    else:\n        optimizer = gtsam.LevenbergMarquardtOptimizer(graph, initial, params)\n\n    # 6.3 Optimize\n    result, optimization_status = _gtsam_optimize(optimizer, params)\n\n    # 7. Process Results\n    l_params = result.atVector(S(0))\n    b = result.atVector(B(0))\n    d = result.atVector(W(0))\n\n    lower_triangular_matrix = np.array([[exp(l_params[0]), 0, 0],\n                                        [l_params[1], exp(l_params[2]), 0],\n                                        [l_params[3], l_params[4], 1 / exp(l_params[0] + l_params[2])]])\n    soft_iron = np.linalg.inv(lower_triangular_matrix @ lower_triangular_matrix.T)\n    hard_iron = soft_iron @ np.vstack(b)\n    gyro_bias = np.vstack(d)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = (np.linalg.inv(soft_iron) @ (magnetic_field.reshape(3, -1) - hard_iron.reshape(3, 1))).T\n\n    # Calibrated gyroscope measurements\n    calibrated_angular_rate = angular_rate - gyro_bias.flatten()\n\n    return (hard_iron.flatten(), soft_iron, gyro_bias.flatten(), calibrated_magnetic_field, calibrated_angular_rate,\n            optimization_status)\n</code></pre>"},{"location":"Proposed%20Methods/magyc_ifg/","title":"MAGYC-IFG","text":"<p>Proposed method for the full calibration of a three-axis magnetometer using magnetic field and angular rate measurements. This particular approach is based on a factor graph processing all the data in an incremental manner.</p> <p>In particular MAGYC-IFG embeds the volume constraint for the soft-iron into a reparametrization for the Cholesky decomposition of the soft-iron matrix, allowing for the use of half the factors.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>angular_rate</code> <code>ndarray or list</code> <p>Angular rate measurements in a 3xN or Nx3 numpy array or list.</p> required <code>time</code> <code>ndarray or list</code> <p>Time stamps of the measurements.</p> required <code>measurements_window</code> <code>int</code> <p>Window size for the measurements.</p> <code>25</code> <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>soft_iron</code> <code>ndarray</code> <p>Soft iron matrix.</p> <code>gyro_bias</code> <code>ndarray</code> <p>Gyroscope bias.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements.</p> <code>calibrated_angular_rate</code> <code>ndarray</code> <p>Calibrated angular rate measurements.</p> <code>optimization_status</code> <code>Dict[str, ndarray]</code> <p>Dictionary with the SI, HI and Wb for each iteartions. The keys are: \"soft_iron\", \"hard_iron\", \"gyro_bias\".</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field, angular rate, and time are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field and angular rate are not 3xN or Nx3 numpy arrays, or if the time is not a 1D numpy array.</p> <code>ValueError</code> <p>If the measurements window is not a positive integer</p> Source code in <code>magyc/methods/magyc.py</code> <pre><code>def magyc_ifg(\n        magnetic_field: Union[np.ndarray, list],\n        angular_rate: Union[np.ndarray, list],\n        time: Union[np.ndarray, list],\n        measurements_window: int = 25\n        ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, Dict[str, np.ndarray]]:\n    \"\"\"\n    Proposed method for the full calibration of a three-axis magnetometer\n    using magnetic field and angular rate measurements. This particular approach\n    is based on a factor graph processing all the data in an incremental manner.\n\n    In particular MAGYC-IFG embeds the volume constraint for the soft-iron into\n    a reparametrization for the Cholesky decomposition of the soft-iron matrix,\n    allowing for the use of half the factors.\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        angular_rate (numpy.ndarray or list): Angular rate measurements in a 3xN or\n            Nx3 numpy array or list.\n        time (numpy.ndarray or list): Time stamps of the measurements.\n        measurements_window (int): Window size for the measurements.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        soft_iron (numpy.ndarray): Soft iron matrix.\n        gyro_bias (numpy.ndarray): Gyroscope bias.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements.\n        calibrated_angular_rate (numpy.ndarray): Calibrated angular rate measurements.\n        optimization_status (Dict[str, np.ndarray]): Dictionary with the SI, HI\n            and Wb for each iteartions. The keys are: \"soft_iron\", \"hard_iron\",\n            \"gyro_bias\".\n\n    Raises:\n        TypeError: If the magnetic field, angular rate, and time are not numpy arrays or lists.\n        ValueError: If the magnetic field and angular rate are not 3xN or Nx3 numpy\n            arrays, or if the time is not a 1D numpy array.\n        ValueError: If the measurements window is not a positive integer\n    \"\"\"\n    # Check if the magnetic_field, angular_rate, and time are lists and convert them to numpy arrays\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n    if isinstance(angular_rate, list):\n        angular_rate = np.array(angular_rate)\n    if isinstance(time, list):\n        time = np.array(time)\n\n    # Check if the magnetic_field, angular_rate, and time are numpy arrays\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field must be a numpy array or a list.\")\n    if not isinstance(angular_rate, np.ndarray):\n        raise TypeError(\"The angular rate must be a numpy array or a list.\")\n    if not isinstance(time, np.ndarray):\n        raise TypeError(\"The time must be a numpy array or a list.\")\n\n    # Check if the magnetic_field and angular_rate are 3xN or Nx3 numpy arrays\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field must be a 3xN or Nx3 numpy array.\")\n    if angular_rate.ndim != 2 or (angular_rate.shape[0] != 3 and angular_rate.shape[1] != 3):\n        raise ValueError(\"The angular rate must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the time is a 1D numpy array\n    time = time.flatten()\n    if time.ndim != 1:\n        raise ValueError(\"The time must be a (n, ), (n, 1) or (1, n) numpy array.\")\n\n    # Force the magnetic_field and angular_rate to be Nx3 numpy arrays\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n    if angular_rate.shape[0] == 3:\n        angular_rate = angular_rate.T\n\n    # Check if the magnetic_field, angular_rate, and time have the same number of samples\n    if magnetic_field.shape[0] != angular_rate.shape[0] or magnetic_field.shape[0] != time.shape[0]:\n        raise ValueError(\"The magnetic field, angular rate, and time must have the same number of samples.\")\n\n    # Check that the measurements window is a positive integer\n    if not isinstance(measurements_window, int) or measurements_window &lt;= 0:\n        raise ValueError(\"The measurements window must be a positive integer.\")\n\n    # Compute the magnetic calibration\n    # Smoothing and Mapping Factor Graph\n    # 1. Create the non-linear graph\n    graph = gtsam.NonlinearFactorGraph()\n\n    # 2. Set iSAM2 parameters and create iSAM2 object\n    isam_parameters = gtsam.ISAM2Params()\n    dogleg_parameters = gtsam.ISAM2DoglegParams()\n    dogleg_parameters.setInitialDelta(0.5)\n    dogleg_parameters.setAdaptationMode(\"ONE_STEP_PER_ITERATION\")\n    isam_parameters.setOptimizationParams(dogleg_parameters)\n    isam = gtsam.ISAM2(isam_parameters)\n\n    # 3. noise model for each factor.\n    residual_noise = gtsam.noiseModel.Isotropic.Sigma(3, 1e-6)\n\n    # 4. Creates values structure with initial values\n    initial = gtsam.Values()\n    initial.insert(S(0), np.array([0.0, 0.0, 0.0, 0.0, 0.0]))\n    initial.insert(B(0), gtsam.Point3(0, 0, 0))\n    initial.insert(W(0), gtsam.Point3(0, 0, 0))\n    keys = [S(0), B(0), W(0)]\n\n    # Dictionary to save the progress of parameters during optimization\n    optimization_status = {\"S\": [], \"B\": [], \"W\": [], \"T\": []}\n\n    # 5. Add factor for each measurement accumulates in the measurements window into a single node\n    measurements_window = int(measurements_window)\n    m_window = np.empty((measurements_window, 3))\n    w_window = np.empty((measurements_window, 3))\n    t_window = np.empty((measurements_window, ))\n\n    # 6. Add factors to the graph\n    for i in range(magnetic_field.shape[0]):\n        # Get sensor measurements and estimated magnetic field derivative\n        t_window[i % measurements_window] = time[i]\n        m_window[i % measurements_window, :] = magnetic_field[i, :]\n        w_window[i % measurements_window, :] = angular_rate[i, :]\n\n        if (i % measurements_window == 0 and i != 0):\n            # Compute the derivative of the magnetic field for the window\n            m_dot_window = np.diff(m_window, axis=0) / np.diff(t_window).reshape(-1, 1)\n\n            # Average measurements by the measurements window size.\n            m_dot_meadian = np.median(m_dot_window, axis=0).reshape(3, 1)\n            m_median = np.median(m_window, axis=0).reshape(3, 1)\n            w_median = np.median(w_window, axis=0).reshape(3, 1)\n\n            # 6.1 Residual factor\n            rf = gtsam.CustomFactor(residual_noise, keys, partial(_residual_factor, m_dot_meadian, m_median, w_median))\n            graph.push_back(rf)\n\n            # 6.2 Perform incremental update to iSAM2's internal Bayes tree, optimizing only the affected variables.\n            # Set iterations to start optimization, otherwise the optimizations starts as a ill-posed problem.\n            # TODO: Fix this\n            # try:\n            if (i // measurements_window) % 10 == 0:\n                isam.update(graph, initial)\n                current = isam.calculateEstimate()\n\n                # Save the current parameters\n                for key, variable in zip([S(0), B(0), W(0)], \"SBW\"):\n                    vector = current.atVector(key).reshape(1, -1)\n                    optimization_status[variable].append(vector)\n                # Save the time as a unix timestamp in microseconds\n                optimization_status[\"T\"].append(int(datetime.now().timestamp() * 1e6))\n\n            # except RuntimeError:\n            #     warnings.warn(\"Skipping graph optimization due to indetermined system.\")\n            # finally:\n                graph = gtsam.NonlinearFactorGraph()\n                initial = gtsam.Values()\n\n            # 6.5 Reset the measurements window\n            t_window = np.empty((measurements_window, ))\n            m_window = np.empty((measurements_window, 3))\n            w_window = np.empty((measurements_window, 3))\n\n    # 7. Process Results\n    # Update optimization status to have the actual matrices instead of the keys\n    optimization_steps = len(optimization_status[\"S\"])\n    optimization_status_final = {\n        \"soft_iron\": np.empty((optimization_steps, 9)),\n        \"hard_iron\": np.empty((optimization_steps, 3)),\n        \"gyro_bias\": np.empty((optimization_steps, 3)),\n        \"time\": np.empty((optimization_steps, ))\n        }\n\n    for i in range(optimization_steps):\n        # Get parameters\n        l_params = optimization_status[\"S\"][i].flatten()\n        b = optimization_status[\"B\"][i]\n        d = optimization_status[\"W\"][i]\n\n        # Compute soft-iron, hard-iron and gyroscope bias\n        lower_triangular_matrix = np.array([[exp(l_params[0]), 0, 0],\n                                            [l_params[1], exp(l_params[2]), 0],\n                                            [l_params[3], l_params[4], 1 / exp(l_params[0] + l_params[2])]])\n        soft_iron_i = np.linalg.inv(lower_triangular_matrix @ lower_triangular_matrix.T)\n        hard_iron_i = soft_iron_i @ b.reshape(3, 1)\n        gyro_bias_i = d.reshape(3, 1)\n\n        # Fill the new optimization status dictionary\n        optimization_status_final[\"soft_iron\"][i, :] = soft_iron_i.flatten()\n        optimization_status_final[\"hard_iron\"][i, :] = hard_iron_i.flatten()\n        optimization_status_final[\"gyro_bias\"][i, :] = gyro_bias_i.flatten()\n        optimization_status_final[\"time\"][i] = optimization_status[\"T\"][i]\n\n    # Average the last 20% of the optimization steps to get the final calibration\n    optimization_steps = int(0.2 * optimization_steps)\n    soft_iron = np.mean(optimization_status_final[\"soft_iron\"][-optimization_steps:], axis=0).reshape(3, 3)\n    hard_iron = np.mean(optimization_status_final[\"hard_iron\"][-optimization_steps:], axis=0)\n    gyro_bias = np.mean(optimization_status_final[\"gyro_bias\"][-optimization_steps:], axis=0)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = (np.linalg.inv(soft_iron) @ (magnetic_field.reshape(3, -1) - hard_iron.reshape(3, 1))).T\n\n    # Calibrated gyroscope measurements\n    calibrated_angular_rate = angular_rate - gyro_bias.flatten()\n\n    return (hard_iron.flatten(), soft_iron, gyro_bias.flatten(), calibrated_magnetic_field, calibrated_angular_rate,\n            optimization_status_final)\n</code></pre>"},{"location":"Proposed%20Methods/magyc_ls/","title":"MAGYC-LS","text":"<p>Proposed method for the full calibration of a three-axis magnetometer using magnetic field and angular rate measurements. This particular approach is based on a least squares optimization and poses the probems as a linear least squares optimization problem.</p> <p>Even tough a closed solution can be computed, it is a ill-conditioned problem and the optimization is preferred.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>angular_rate</code> <code>ndarray or list</code> <p>Angular rate measurements in a 3xN or Nx3 numpy array or list.</p> required <code>time</code> <code>ndarray or list</code> <p>Time stamps of the measurements.</p> required <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>soft_iron</code> <code>ndarray</code> <p>Soft iron matrix.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field, angular rate, and time are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field and angular rate are not 3xN or Nx3 numpy arrays, or if the time is not a 1D numpy array.</p> Source code in <code>magyc/methods/magyc.py</code> <pre><code>def magyc_ls(magnetic_field: Union[np.ndarray, list], angular_rate: Union[np.ndarray, list],\n             time: Union[np.ndarray, list]) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Proposed method for the full calibration of a three-axis magnetometer\n    using magnetic field and angular rate measurements. This particular approach\n    is based on a least squares optimization and poses the probems as a linear\n    least squares optimization problem.\n\n    Even tough a closed solution can be computed, it is a ill-conditioned problem\n    and the optimization is preferred.\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        angular_rate (numpy.ndarray or list): Angular rate measurements in a 3xN or\n            Nx3 numpy array or list.\n        time (numpy.ndarray or list): Time stamps of the measurements.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        soft_iron (numpy.ndarray): Soft iron matrix.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements.\n\n    Raises:\n        TypeError: If the magnetic field, angular rate, and time are not numpy arrays or lists.\n        ValueError: If the magnetic field and angular rate are not 3xN or Nx3 numpy\n            arrays, or if the time is not a 1D numpy array.\n    \"\"\"\n    # Check if the magnetic_field, angular_rate, and time are lists and convert them to numpy arrays\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n    if isinstance(angular_rate, list):\n        angular_rate = np.array(angular_rate)\n    if isinstance(time, list):\n        time = np.array(time)\n\n    # Check if the magnetic_field, angular_rate, and time are numpy arrays\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field must be a numpy array or a list.\")\n    if not isinstance(angular_rate, np.ndarray):\n        raise TypeError(\"The angular rate must be a numpy array or a list.\")\n    if not isinstance(time, np.ndarray):\n        raise TypeError(\"The time must be a numpy array or a list.\")\n\n    # Check if the magnetic_field and angular_rate are 3xN or Nx3 numpy arrays\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field must be a 3xN or Nx3 numpy array.\")\n    if angular_rate.ndim != 2 or (angular_rate.shape[0] != 3 and angular_rate.shape[1] != 3):\n        raise ValueError(\"The angular rate must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the time is a 1D numpy array\n    time = time.flatten()\n    if time.ndim != 1:\n        raise ValueError(\"The time must be a (n, ), (n, 1) or (1, n) numpy array.\")\n\n    # Force the magnetic_field and angular_rate to be Nx3 numpy arrays\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n    if angular_rate.shape[0] == 3:\n        angular_rate = angular_rate.T\n\n    # Check if the magnetic_field, angular_rate, and time have the same number of samples\n    if magnetic_field.shape[0] != angular_rate.shape[0] or magnetic_field.shape[0] != time.shape[0]:\n        raise ValueError(\"The magnetic field, angular rate, and time must have the same number of samples.\")\n\n    # Compute the skew symmetric matrix of the angular rate\n    skew_symmetric_angular_rate = np.apply_along_axis(_vec_to_so3_jax, 1, angular_rate)\n\n    # Compute the magnetic field derivative\n    magnetic_field_derivative = np.diff(magnetic_field, axis=0) / np.diff(time).reshape(-1, 1)\n    magnetic_field_derivative = np.concatenate([np.zeros((1, 3)), magnetic_field_derivative], axis=0).reshape(-1, 3, 1)\n\n    # Reshape magnetic field\n    magnetic_field_3d = magnetic_field.reshape(-1, 3, 1)\n\n    # Compute the magnetic calibration\n    # Least Squares Initial Guess and Constraints\n    x0 = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n\n    # Optimization\n    res = scipy.optimize.least_squares(\n        _magyc_ls_cost_function,\n        x0,\n        jac=_magyc_ls_jacobian,\n        method=\"dogbox\",\n        verbose=0,\n        loss=\"linear\",\n        max_nfev=1000,\n        ftol=1.00e-06,\n        gtol=None,\n        xtol=None,\n        x_scale=\"jac\",\n        args=(magnetic_field_3d, magnetic_field_derivative, skew_symmetric_angular_rate)\n    )\n\n    # Compute SI and HI\n    x = res[\"x\"]\n    lower_triangular_matrix = np.array([[exp(x[0]), 0, 0], [x[1], exp(x[2]), 0], [x[3], x[4], 1 / exp(x[0] + x[2])]])\n    soft_iron = np.linalg.inv(lower_triangular_matrix @ lower_triangular_matrix.T)\n    hard_iron = soft_iron @ x[5:].reshape(3, 1)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = (np.linalg.inv(soft_iron) @ (magnetic_field.reshape(3, -1) - hard_iron.reshape(3, 1))).T\n\n    return hard_iron.flatten(), soft_iron, calibrated_magnetic_field\n</code></pre>"},{"location":"Proposed%20Methods/magyc_nls/","title":"MAGYC-NLS","text":"<p>Proposed method for the full calibration of a three-axis magnetometer and a three-axis gyroscope using magnetic field and angular rate measurements. This particular approach is based on a least squares optimization and poses the probems as a non-linear least squares optimization problem.</p> <p>Parameters:</p> Name Type Description Default <code>magnetic_field</code> <code>ndarray or list</code> <p>Magnetic field measurements in a 3xN or Nx3 numpy array or list.</p> required <code>angular_rate</code> <code>ndarray or list</code> <p>Angular rate measurements in a 3xN or Nx3 numpy array or list.</p> required <code>time</code> <code>ndarray or list</code> <p>Time stamps of the measurements.</p> required <p>Returns:</p> Name Type Description <code>hard_iron</code> <code>ndarray</code> <p>Hard iron bias.</p> <code>soft_iron</code> <code>ndarray</code> <p>Soft iron matrix.</p> <code>gyro_bias</code> <code>ndarray</code> <p>Gyroscope bias.</p> <code>calibrated_magnetic_field</code> <code>ndarray</code> <p>Calibrated magnetic field measurements.</p> <code>calibrated_angular_rate</code> <code>ndarray</code> <p>Calibrated angular rate measurements.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the magnetic field, angular rate, and time are not numpy arrays or lists.</p> <code>ValueError</code> <p>If the magnetic field and angular rate are not 3xN or Nx3 numpy arrays, or if the time is not a 1D numpy array.</p> Source code in <code>magyc/methods/magyc.py</code> <pre><code>def magyc_nls(magnetic_field: Union[np.ndarray, list], angular_rate: Union[np.ndarray, list],\n              time: Union[np.ndarray, list]) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Proposed method for the full calibration of a three-axis magnetometer\n    and a three-axis gyroscope using magnetic field and angular rate measurements.\n    This particular approach is based on a least squares optimization and poses\n    the probems as a non-linear least squares optimization problem.\n\n    Args:\n        magnetic_field (numpy.ndarray or list): Magnetic field measurements in a\n            3xN or Nx3 numpy array or list.\n        angular_rate (numpy.ndarray or list): Angular rate measurements in a 3xN or\n            Nx3 numpy array or list.\n        time (numpy.ndarray or list): Time stamps of the measurements.\n\n    Returns:\n        hard_iron (numpy.ndarray): Hard iron bias.\n        soft_iron (numpy.ndarray): Soft iron matrix.\n        gyro_bias (numpy.ndarray): Gyroscope bias.\n        calibrated_magnetic_field (numpy.ndarray): Calibrated magnetic field measurements.\n        calibrated_angular_rate (numpy.ndarray): Calibrated angular rate measurements.\n\n    Raises:\n        TypeError: If the magnetic field, angular rate, and time are not numpy arrays or lists.\n        ValueError: If the magnetic field and angular rate are not 3xN or Nx3 numpy\n            arrays, or if the time is not a 1D numpy array.\n    \"\"\"\n    # Check if the magnetic_field, angular_rate, and time are lists and convert them to numpy arrays\n    if isinstance(magnetic_field, list):\n        magnetic_field = np.array(magnetic_field)\n    if isinstance(angular_rate, list):\n        angular_rate = np.array(angular_rate)\n    if isinstance(time, list):\n        time = np.array(time)\n\n    # Check if the magnetic_field, angular_rate, and time are numpy arrays\n    if not isinstance(magnetic_field, np.ndarray):\n        raise TypeError(\"The magnetic field must be a numpy array or a list.\")\n    if not isinstance(angular_rate, np.ndarray):\n        raise TypeError(\"The angular rate must be a numpy array or a list.\")\n    if not isinstance(time, np.ndarray):\n        raise TypeError(\"The time must be a numpy array or a list.\")\n\n    # Check if the magnetic_field and angular_rate are 3xN or Nx3 numpy arrays\n    if magnetic_field.ndim != 2 or (magnetic_field.shape[0] != 3 and magnetic_field.shape[1] != 3):\n        raise ValueError(\"The magnetic field must be a 3xN or Nx3 numpy array.\")\n    if angular_rate.ndim != 2 or (angular_rate.shape[0] != 3 and angular_rate.shape[1] != 3):\n        raise ValueError(\"The angular rate must be a 3xN or Nx3 numpy array.\")\n\n    # Check if the time is a 1D numpy array\n    time = time.flatten()\n    if time.ndim != 1:\n        raise ValueError(\"The time must be a (n, ), (n, 1) or (1, n) numpy array.\")\n\n    # Force the magnetic_field and angular_rate to be Nx3 numpy arrays\n    if magnetic_field.shape[0] == 3:\n        magnetic_field = magnetic_field.T\n    if angular_rate.shape[0] == 3:\n        angular_rate = angular_rate.T\n\n    # Check if the magnetic_field, angular_rate, and time have the same number of samples\n    if magnetic_field.shape[0] != angular_rate.shape[0] or magnetic_field.shape[0] != time.shape[0]:\n        raise ValueError(\"The magnetic field, angular rate, and time must have the same number of samples.\")\n\n    # Compute the skew symmetric matrix of the angular rate\n    skew_symmetric_angular_rate = npj.apply_along_axis(_vec_to_so3_jax, 1, angular_rate)\n\n    # Compute the magnetic field derivative\n    magnetic_field_derivative = np.diff(magnetic_field, axis=0) / np.diff(time).reshape(-1, 1)\n    magnetic_field_derivative = np.vstack([np.zeros((1, 3)), magnetic_field_derivative]).reshape(-1, 3, 1)\n\n    # Reshape magnetic field\n    magnetic_field_3d = magnetic_field.reshape(-1, 3, 1)\n\n    # Compute the magnetic calibration\n    # Least Squares Initial Guess and Constraints\n    x0 = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n\n    # Optimization\n    res = scipy.optimize.least_squares(\n        _magyc_nls_cost_function,\n        x0,\n        method=\"dogbox\",\n        jac=_compute_jacobian_nls_jax,\n        verbose=0,\n        loss=\"linear\",\n        max_nfev=1000,\n        ftol=1.00e-06,\n        gtol=None,\n        xtol=None,\n        x_scale=\"jac\",\n        args=(magnetic_field_3d, magnetic_field_derivative, skew_symmetric_angular_rate)\n    )\n\n    # Compute SI, HI and Wb\n    x = res[\"x\"]\n    lower_triangular_matrix = np.array([[exp(x[0]), 0, 0], [x[1], exp(x[2]), 0], [x[3], x[4], 1 / exp(x[0] + x[2])]])\n    soft_iron = np.linalg.inv(lower_triangular_matrix @ lower_triangular_matrix.T)\n    hard_iron = soft_iron @ x[5:8].reshape(3, 1)\n    gyro_bias = x[8:].reshape(3, 1)\n\n    # Calibrate magnetic field\n    calibrated_magnetic_field = (np.linalg.inv(soft_iron) @ (magnetic_field.reshape(3, -1) - hard_iron.reshape(3, 1))).T\n\n    # Calibrated gyroscope measurements\n    calibrated_angular_rate = angular_rate - gyro_bias.flatten()\n\n    return hard_iron.flatten(), soft_iron, gyro_bias.flatten(), calibrated_magnetic_field, calibrated_angular_rate\n</code></pre>"},{"location":"Synthetic%20Data/synthetic_data_generation/","title":"Synthetic Data Generation","text":"<p>Creates a synthetic dataset using a constant magnetic vector that is randomly rotated in three different degrees of motion: low, mid, and high. The created data is saved in the folderPath directory as a pickle (.pkl) file. The file's name uses the date of its creation as: yyyymmdd_hhmm.pkl</p> <p>The data provided is: magnetic field (m), magnetic field with added noise (mt), magnetic field with HSI (mm), magnetic field with HSI and noise (mmt), angular rates (w), angular rates with noise (wt), angular rates with gyroscope bias (wm), angular rate with gyroscope bias and noise (wmt), attitude (rph), time (t), ground truth magnetic vector (m0), soft iron (si), hard iron (hi), and gyroscope bias (wb).</p> <p>For each level of movement the data is provided as a multi-dimensional array, where the shape is: (simulation, samples, 3).</p> <p>If not random, the soft iron, hard iron, and gyroscope biases are fixed as follows:</p> \\[ SI = \\begin{bmatrix} 1.10 &amp; 0.10 &amp; 0.04 \\\\                           0.10 &amp; 0.88 &amp; 0.02 \\\\                           0.04 &amp; 0.02 &amp; 1.22 \\end{bmatrix} \\] \\[ HI = \\begin{bmatrix} 0.020 &amp; 0.120 &amp; 0.090 \\end{bmatrix}^T \\] \\[ WB = \\begin{bmatrix} 0.004 &amp; -0.005 &amp; 0.002 \\end{bmatrix}^T \\] <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>Path</code> <p>Folder to save the data as a pickle (.pkl) file.</p> required <code>niter</code> <code>int</code> <p>Number of simulations per motion level, by default 100</p> <code>100</code> <code>nsamples</code> <code>int</code> <p>Number of samples per simulation, by default 10000</p> <code>10000</code> <code>frequency</code> <code>float</code> <p>Simulated sensor frequency, by default 25</p> <code>25.0</code> <code>mag_noise_G</code> <code>float</code> <p>Noise for the magnetic measurements in G.</p> <code>0.01</code> <code>gyro_noise_rad_s</code> <code>float</code> <p>Noise for the gyroscope measurements in rad/s</p> <code>0.005</code> <code>random</code> <code>bool</code> <p>If True, the soft iron, hard iron, and gyroscope biases are randomly generated. If False, the soft iron, hard iron, and gyroscope biases are fixed, by default False.</p> <code>False</code> <code>scale_factor</code> <code>float</code> <p>Scale factor for the SI, HI, and WB matrices, by default 1.0</p> <code>1.0</code> Source code in <code>magyc/sim_data/generate_data.py</code> <pre><code>def create_synthetic_dataset(folder_path: Path, niter: int = 100, nsamples: int = 10000, frequency: float = 25.0,\n                             mag_noise_G: float = 0.01, gyro_noise_rad_s: float = 0.005, random: bool = False,\n                             scale_factor: float = 1.0) -&gt; None:\n    \"\"\"\n    Creates a synthetic dataset using a constant magnetic vector that is\n    randomly rotated in three different degrees of motion: low, mid, and high.\n    The created data is saved in the folderPath directory as a pickle (.pkl)\n    file. The file's name uses the date of its creation as: yyyymmdd_hhmm.pkl\n\n    The data provided is: magnetic field (m), magnetic field with added noise\n    (mt), magnetic field with HSI (mm), magnetic field with HSI and noise (mmt),\n    angular rates (w), angular rates with noise (wt), angular rates with gyroscope\n    bias (wm), angular rate with gyroscope bias and noise (wmt), attitude (rph),\n    time (t), ground truth magnetic vector (m0), soft iron (si), hard iron (hi),\n    and gyroscope bias (wb).\n\n    For each level of movement the data is provided as a multi-dimensional array,\n    where the shape is: (simulation, samples, 3).\n\n    If not random, the soft iron, hard iron, and gyroscope biases are fixed as\n    follows:\n\n    \\\\[ SI = \\\\begin{bmatrix} 1.10 &amp; 0.10 &amp; 0.04 \\\\\\\\\n                              0.10 &amp; 0.88 &amp; 0.02 \\\\\\\\\n                              0.04 &amp; 0.02 &amp; 1.22 \\\\end{bmatrix} \\\\]\n\n    \\\\[ HI = \\\\begin{bmatrix} 0.020 &amp; 0.120 &amp; 0.090 \\\\end{bmatrix}^T \\\\]\n\n    \\\\[ WB = \\\\begin{bmatrix} 0.004 &amp; -0.005 &amp; 0.002 \\\\end{bmatrix}^T \\\\]\n\n    Args:\n        folder_path (Path): Folder to save the data as a pickle (.pkl) file.\n        niter (int): Number of simulations per motion level, by default 100\n        nsamples (int): Number of samples per simulation, by default 10000\n        frequency (float): Simulated sensor frequency, by default 25\n        mag_noise_G (float): Noise for the magnetic measurements in G.\n        gyro_noise_rad_s (float): Noise for the gyroscope measurements in rad/s\n        random (bool): If True, the soft iron, hard iron, and gyroscope biases\n            are randomly generated. If False, the soft iron, hard iron, and\n            gyroscope biases are fixed, by default False.\n        scale_factor (float): Scale factor for the SI, HI, and WB matrices, by\n            default 1.0\n    \"\"\"\n    if not random:\n        # Adimensional and positive definite symmetric (PDS) matrix\n        SI = np.array([[1.10, 0.10, 0.04],\n                       [0.10, 0.88, 0.02],\n                       [0.04, 0.02, 1.22]])\n        SI = scale_factor * SI\n        # G\n        HI = np.array([[0.020],\n                       [0.120],\n                       [0.090]])\n        HI = scale_factor * HI\n        # rad/s\n        WB = np.array([[0.004],\n                       [-0.005],\n                       [0.002]])\n        WB = scale_factor * WB\n\n    # Check if folder is a directory\n    if not isdir(folder_path):\n        raise ValueError(\"The provided folder is not a directory in the system\")\n\n    # Create dataset generator object\n    sd = _SyntheticData(niter=niter, nsamples=nsamples, frequency=frequency, mag_noise_G=mag_noise_G,\n                        gyro_noise_rad_s=gyro_noise_rad_s)\n\n    # Set calibration parameters\n    if random:\n        sd.random_parameters()\n    else:\n        sd.fixed_parameters(SI, HI, WB)\n\n    # Generate Dataset\n    sd.generate_data(folder_path)\n</code></pre>"},{"location":"Utilities/hsi_calibration_validation/","title":"HSI Calibration Validation","text":"<p>Check if the computed soft-iron and hard-iron matrices correspond to the parametrization of an ellipsoid in the real numbers domain and if meet the positive definite condition for the soft-iron.</p> Conditions <ul> <li>cond1: The rank of matrix S should be 3.</li> <li>cond2: The rank of matrix E should be 4.</li> <li>cond3: The determinant of matrix E should be less than 0.</li> <li>cond4: All eigenvalues of matrix S should be positive.</li> <li>cond5: All eigenvalues of the soft-iron matrix should be positive.</li> </ul> Explanation <ul> <li>S: A matrix derived from the inverse of the soft-iron matrix. It is      used to check the positive definite condition.</li> <li>P: A matrix derived from the hard-iron matrix and the inverse of the      soft-iron matrix. It represents the linear part of the ellipsoid      equation.</li> <li>d: A scalar value derived from the hard-iron matrix and the inverse of      the soft-iron matrix. It represents the constant part of the ellipsoid      equation.</li> <li>E: A block matrix constructed from S, P, and d. It represents the full      ellipsoid equation in matrix form.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>soft_iron</code> <code>ndarray</code> <p>Soft-iron matrix as a (3, 3) numpy array.</p> required <code>hard_iron</code> <code>ndarray</code> <p>Hard-iron matrix as a (3, 1) numpy array.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the soft-iron and hard-iron parametrize a ellipsoid in the</p> <code>bool</code> <p>real numbers domain.</p> Source code in <code>magyc/utils/utils.py</code> <pre><code>def hsi_calibration_validation(soft_iron: np.ndarray, hard_iron: np.ndarray) -&gt; bool:\n    \"\"\"\n    Check if the computed soft-iron and hard-iron matrices correspond to the\n    parametrization of an ellipsoid in the real numbers domain and if meet\n    the positive definite condition for the soft-iron.\n\n    Conditions:\n        - cond1: The rank of matrix S should be 3.\n        - cond2: The rank of matrix E should be 4.\n        - cond3: The determinant of matrix E should be less than 0.\n        - cond4: All eigenvalues of matrix S should be positive.\n        - cond5: All eigenvalues of the soft-iron matrix should be positive.\n\n    Explanation:\n        - S: A matrix derived from the inverse of the soft-iron matrix. It is\n             used to check the positive definite condition.\n        - P: A matrix derived from the hard-iron matrix and the inverse of the\n             soft-iron matrix. It represents the linear part of the ellipsoid\n             equation.\n        - d: A scalar value derived from the hard-iron matrix and the inverse of\n             the soft-iron matrix. It represents the constant part of the ellipsoid\n             equation.\n        - E: A block matrix constructed from S, P, and d. It represents the full\n             ellipsoid equation in matrix form.\n\n    Args:\n        soft_iron (np.ndarray): Soft-iron matrix as a (3, 3) numpy array.\n        hard_iron (np.ndarray): Hard-iron matrix as a (3, 1) numpy array.\n\n    Returns:\n        bool: Whether the soft-iron and hard-iron parametrize a ellipsoid in the\n        real numbers domain.\n    \"\"\"\n    soft_iron, hard_iron = soft_iron.reshape(3, 3), hard_iron.reshape(-1, 1)\n    soft_iron_inv = np.linalg.inv(soft_iron)\n    S = soft_iron_inv.T @ soft_iron_inv\n    P = -hard_iron.T @ soft_iron_inv.T @ soft_iron_inv\n    d = -(hard_iron.T @ soft_iron_inv.T @ soft_iron_inv @ hard_iron + 1)\n\n    # Create block matrix with S, P and d\n    E = np.block([[S, P.T], [P, d]])\n\n    # Conditions\n    try:\n        cond1 = np.linalg.matrix_rank(S) == 3\n        cond2 = np.linalg.matrix_rank(E) == 4\n        cond3 = np.linalg.det(E) &lt; 0\n        cond4 = all([i &gt; 0 for i in np.linalg.eigvals(S)])\n        cond5 = all([i &gt; 0 for i in np.linalg.eigvals(soft_iron)])\n    except Exception as e:\n        warn(f\"An error occurred while validating the calibration matrices: {e}\")\n        return False\n\n    return all([cond1, cond2, cond3, cond4, cond5])\n</code></pre>"},{"location":"Utilities/pds_geodesic_distance/","title":"PDS Geodesic Distance","text":"<p>Geodesic distance between two positive definite symmetrics matrices based on Bhatia (2007) [1]. This metrics is the affine-invariant Riemannian distance between two positive definite symmetric matrices.</p> <p>[1] Bhatia, R. (2007). Positive Definite Matrices. Princeton: Princeton University Press. https://doi.org/10.1515/9781400827787</p> <p>Parameters:</p> Name Type Description Default <code>pds_0</code> <code>ndarray</code> <p>Positive definite symmetric matrix.</p> required <code>pds_1</code> <code>ndarray</code> <p>Positive definite symmetric matrix.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Distance between the two matrices.</p> Source code in <code>magyc/utils/utils.py</code> <pre><code>def pds_geodesic_distance(pds_0: np.ndarray, pds_1: np.ndarray) -&gt; float:\n    \"\"\"\n    Geodesic distance between two positive definite symmetrics matrices based on Bhatia (2007) [1]. This metrics is the\n    affine-invariant Riemannian distance between two positive definite symmetric matrices.\n\n    [1] Bhatia, R. (2007). Positive Definite Matrices. Princeton: Princeton University Press.\n    https://doi.org/10.1515/9781400827787\n\n    Args:\n        pds_0 (np.ndarray): Positive definite symmetric matrix.\n        pds_1 (np.ndarray): Positive definite symmetric matrix.\n\n    Returns:\n        Distance between the two matrices.\n    \"\"\"\n    return np.linalg.norm(logm(pds_0) - logm(pds_1), 'fro')\n</code></pre>"}]}